# list에 key를 설정하는 이유

  * DOM 노드의 자식들을 재귀적으로 처리시, React는 기본적으로 동시에 두 리스트를 순회하고 차이점이 있으면 변경 생성
  * key를 통해 기존 트리와 이후 트리의 자식들이 일치하는지 확인합니다.
  * 키를 사용하면 비효율의 문제를 해결할 수 있음, 트리 벼노한 작업이 효율적으로 수행됩니다.

# Index as a key is anti-pattern

1. 
  * key는 리액트가 DOM element를 identify 하는 유일한 요소이다.
  * key로 아무것도 주지 않을 때 React에서 index를 기본적으로 키로 사용함, React는 사용자가 예상못한 결과를 만들 것을 알거라고 생각
2. 
  * 중간에 새로운 요소를 추가하거나, 삭제할 경우 재배열 시 비효율적으로 동작함
  * 인덱스를 키로 사용하는 배열이 재배열되면 컴포넌트 state와 관련된 문제도 발생 가능
3. 
  * 컴포넌트 인스턴스는 key를 기반으로 갱신되고 재사용
  * 인덱스를 key로 사용하면, 항목의 순서가 바뀌었을 때 key 또한 바뀜, 그 결과 컴포넌트의 state가 엉망이 되거나 의도치 않은 방식으로 바뀜

# key 조건

  * 반드시 변하지 않고, 예상 가능하며, 유일해야 함
  * 변하는 값 (Math.random()으로 생성된 값)을 key 로 사용하면 많은 컴포넌트 인스턴스와 DOM 노드를 불필요하게 재생성하여 성능이 나빠지거나 자식 컴포넌트의 state가 유실될 수도 있음

# 제어 컴포넌트

  * <form>, <input>, <textarea>, <select>와 같은 폼엘리먼트에서 React state에 의해 입력값이 제어되는 것
  * React의 state가 single source of truth로 설정해두어서 폼에서 발생하는 사용자 입력값을 제어함
  * 이러한 리액트에 의해 값이 제어 되는 입력폼을 제어 컴포넌트라고 함
  * input 값이 항상 React state에 의해 결정됨

# setState가 비동기적인 이유

  * 이벤트 핸들러 내에서 setState가 비동기적인데, 그 이유느 부모와 자식에서 호출한다면 자식은 두번 렌더링되지 않는다. 그 대신에 브라우저 이벤트가 끝날 시점에 state를 일괄적으로 업데이트 하는데 더 큰 규모의 앱에서는 뚜렷한 성능향상을 만듦