# list에 key를 설정하는 이유

  * DOM 노드의 자식들을 재귀적으로 처리시, React는 기본적으로 동시에 두 리스트를 순회하고 차이점이 있으면 변경 생성
  * key를 통해 기존 트리와 이후 트리의 자식들이 일치하는지 확인합니다.
  * 키를 사용하면 비효율의 문제를 해결할 수 있음, 트리 벼노한 작업이 효율적으로 수행됩니다.

# Index as a key is anti-pattern

1. 
  * key는 리액트가 DOM element를 identify 하는 유일한 요소이다.
  * key로 아무것도 주지 않을 때 React에서 index를 기본적으로 키로 사용함, React는 사용자가 예상못한 결과를 만들 것을 알거라고 생각
2. 
  * 중간에 새로운 요소를 추가하거나, 삭제할 경우 재배열 시 비효율적으로 동작함
  * 인덱스를 키로 사용하는 배열이 재배열되면 컴포넌트 state와 관련된 문제도 발생 가능
3. 
  * 컴포넌트 인스턴스는 key를 기반으로 갱신되고 재사용
  * 인덱스를 key로 사용하면, 항목의 순서가 바뀌었을 때 key 또한 바뀜, 그 결과 컴포넌트의 state가 엉망이 되거나 의도치 않은 방식으로 바뀜
* 컴포넌트 인스턴스는 key를 기반으로 갱신되고 재사용되는데, 인덱스를 key로 하면, 항목의 순서가 바뀌었을 때 key또한 바뀌게 되고, 그 결과 컴포넌트의 state가 엉망이 되거나 의도치 않은 방식으로 바뀔 수도 있다.

# key 조건

  * 반드시 변하지 않고, 예상 가능하며, 유일해야 함
  * 변하는 값 (Math.random()으로 생성된 값)을 key 로 사용하면 많은 컴포넌트 인스턴스와 DOM 노드를 불필요하게 재생성하여 성능이 나빠지거나 자식 컴포넌트의 state가 유실될 수도 있음

# 제어 컴포넌트

  * <form>, <input>, <textarea>, <select>와 같은 폼엘리먼트에서 React state에 의해 입력값이 제어되는 것
  * React의 state가 single source of truth로 설정해두어서 폼에서 발생하는 사용자 입력값을 제어함
  * 이러한 리액트에 의해 값이 제어 되는 입력폼을 제어 컴포넌트라고 함
  * input 값이 항상 React state에 의해 결정됨

# setState가 비동기적인 이유

  * 이벤트 핸들러 내에서 setState가 비동기적인데, 그 이유느 부모와 자식에서 호출한다면 자식은 두번 렌더링되지 않는다. 그 대신에 브라우저 이벤트가 끝날 시점에 state를 일괄적으로 업데이트 하는데 더 큰 규모의 앱에서는 뚜렷한 성능향상을 만듦

# useMemo와 useCallback

  * useMemo는 useMemo(fn, [dependency])로 사용하고, dependency가 변경됐을 때 새로 fn에 인자로 dependency가 들어가서 값이 저장되고, 아닐 경우 저장된 값이 주어짐
  * useCallback은 useMemo와 유사하지만, useMemo와 달리 값이 아닌 함수가 반환된다.
  * 사용 시점
    * 둘 다 최적화를 위해 주로 사용함 (하지만, 알기 어려움, 우선 측정해보기)
    * useEffect에서 dependency가 reference type으로 측정이 어려울때 (참조 동일성)
    * 고비용의 복잡한 연산(함수)이 사용될때

# PropTypes

  * PropTypes는 리액트에 내장된 타입 검사 기능
  * 컴포넌트의 props의 타입을 검사할 수 있다.
  * 전달받은 데이터의 유효성 검사를 위해 다양한 유효성 검사기(validator)가 있음
    * string, array, object, number... 다양함, 사용시 문서를 확인해보자.
  * 성능상의 이유로 개발 모드 (development mode)에서만 확인 가능하다.
  * defaultProps로 초기값을 설정해 둘 수 있다.

# Fragments

  * DOM에 별도의 노드를 추가하지 않고 여러 자식을 그룹화하는 방법
  * 단축 문법으로 <></> 로 사용한다.
  * map을 이용해서 key를 넣어줘야할 경우엔 <React.Fragment key={id}></React.Fragment> 로 사용한다. (<Fragment key={id}></Fragment>로도 사용가능)
