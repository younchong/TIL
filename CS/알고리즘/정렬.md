# 선택 정렬 (Selection Sort)

* 가장 직관적이고 구현하기 쉬움 (가장 작은것을 제일 앞으로 보낸다)
* 시간 복잡도 O(N^2)
* 다른 알고리즘 비교 비효율적이고 느린 알고리즘

### JS코드
```
const unsorted = [2, 7, 1, 3, 6, 8, 10, 5, 9, 4];

for (let i = 0; i < 10; i++) {
  let temp;
  let index;
  let min = 999;
  for (let j = i; j < 10; j++) {
    if (min > unsorted[j]) {
      min = unsorted[j];
      index = j
    }
  }

  temp = unsorted[i]; // 최솟값과 교환될 값
  unsorted[i] = unsorted[index]; // 최솟값이 맨 앞으로 이동
  unsorted[index] = temp; // 원래 최솟값있던 자리랑 교환
}
```

# 버블 정렬 (Bubble Sort)

* 옆에 있는 값과 비교해서 자리 바꾸기
* 간단하고 직관적
* 가장 효율이 떨어지고 느림 (매번 교체를 해서)
* 시간 복잡도 O(N^2)  (같은 시간복잡도라도 위와 같은 이유로 실제로는 더 느림)

### JS코드
```
const unsorted = [2, 3, 10, 8, 1, 5, 7, 4, 6, 9];

for (let i = 0; i < 10; i++) {
  for (let j = 0; j < 9 - i; j++) {
    if (unsorted[j] > unsorted[j + 1]) {
      let temp = unsorted[j];
      unsorted[j] = unsorted[j + 1];
      unsorted[j + 1] = temp;
    }
  }
}
```

# 삽입 정렬 (Insertion Sort)

* 삽입 정렬은 숫자를 적절한 위치에 삽입하는 알고리즘으로, 필요할 때만 위치를 변경
* 앞의 두 정렬과 비교해선 제일 빠르고, 효율적 (연산이 적음)
* 정렬이 되어있다고 가정 한다는 점에서 특정한 경우에 굉장히 빠름
* 거의 정렬된 상태라면 삽입정렬이 가장 효율적이고 빠름
* 시간 복잡도 O(N^2) (그래도 위의 이유로 앞 선 두 정렬보단 빠름)

### JS코드
```
const unsorted = [10, 2, 1, 8, 6, 3, 9, 4, 7, 5];

for (let i = 0; i < 9; i++) {
  while (i >= 0 && unsorted[i] > unsorted[i + 1]) {
    let temp = unsorted[i];
    unsorted[i] = unsorted[i + 1];
    unsoted[i + 1] = temp;
    i--;
  }
}
```

# 퀵 정렬 (Quick sort)

* 퀵 정렬은 대표적인 분할 정복 알고리즘으로 특정 값을 기준으로 큰 숫자와 작은 숫자로 나누는 개념이다.(잘게 나눈 후 정렬 후 합치기)
* 특정값, 기준값은 피벗이라고 함
* 시간 복잡도 O(N * logN), 굉장히 연산 속도 빠르고 효율적
* 이미 거의 정렬되어 있는 상태면 최악의 시간 복잡도 O(N*2)이 됨
* 정렬할 데이터 특성에 맞게 적절한 알고리즘을 사용하는 것이 바람직함, 일반적으론 퀵정렬이 빠르지만 거의 정렬되어 있는 data라면 삽입정렬이 더 빠름 
### JS코드
```
const unsorted = [10, 2, 5, 8, 6, 1, 4, 7, 3, 9];

function quickSort (data, start, end) {
  if (start >= end) {
    return;
  }

  let i = start + 1;
  let j = end;
  let key = start;
  let temp;

  while (i <= j) { //엇갈릴때 까지 반복
    while (i <= end && data[i] <= data[key]) { // 키 값보다 큰 값 찾기 -> 처음부터(키 바로 옆에서 부터)
      i++;
    }
    while (j > start && data[j] >= data[key]) { // 키값보다 작은 값 찾기 <- 끝에서부터
      j--;
    }

    if (i > j) { // 엇갈리면(key값보다 작거나 큰값이 없을 때) 키 값과 작은값 교체
      temp = data[j];
      data[j] = data[key];
      data[key] = temp;
    } else { // 엇갈리지 않으면, key값보다 작거나 큰값을 있을 경우
      temp = data[j];
      data[j] = data[i];
      data[i] = temp;
    }
  }

  quickSort(data, start, j - 1);
  quickSort(data, j + 1, end);
}
```
