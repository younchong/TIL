# 선택 정렬 (Selection Sort)

* 가장 직관적이고 구현하기 쉬움 (가장 작은것을 제일 앞으로 보낸다)
* 시간 복잡도 O(N^2)
* 다른 알고리즘 비교 비효율적이고 느린 알고리즘

### JS코드
```
const unsorted = [2, 7, 1, 3, 6, 8, 10, 5, 9, 4];

for (let i = 0; i < 10; i++) {
  let temp;
  let index;
  let min = 999;
  for (let j = i; j < 10; j++) {
    if (min > unsorted[j]) {
      min = unsorted[j];
      index = j
    }
  }

  temp = unsorted[i]; // 최솟값과 교환될 값
  unsorted[i] = unsorted[index]; // 최솟값이 맨 앞으로 이동
  unsorted[index] = temp; // 원래 최솟값있던 자리랑 교환
}
```

# 버블 정렬 (Bubble Sort)

* 옆에 있는 값과 비교해서 자리 바꾸기
* 간단하고 직관적
* 가장 효율이 떨어지고 느림 (매번 교체를 해서)
* 시간 복잡도 O(N^2)  (같은 시간복잡도라도 위와 같은 이유로 실제로는 더 느림)

### JS코드
```
const unsorted = [2, 3, 10, 8, 1, 5, 7, 4, 6, 9];

for (let i = 0; i < 10; i++) {
  for (let j = 0; j < 9 - i; j++) {
    if (unsorted[j] > unsorted[j + 1]) {
      let temp = unsorted[j];
      unsorted[j] = unsorted[j + 1];
      unsorted[j + 1] = temp;
    }
  }
}
```

# 삽입 정렬 (Insertion Sort)

* 삽입 정렬은 숫자를 적절한 위치에 삽입하는 알고리즘으로, 필요할 때만 위치를 변경
* 앞의 두 정렬과 비교해선 제일 빠르고, 효율적 (연산이 적음)
* 정렬이 되어있다고 가정 한다는 점에서 특정한 경우에 굉장히 빠름
* 거의 정렬된 상태라면 삽입정렬이 가장 효율적이고 빠름
* 시간 복잡도 O(N^2) (그래도 위의 이유로 앞 선 두 정렬보단 빠름)

### JS코드
```
const unsorted = [10, 2, 1, 8, 6, 3, 9, 4, 7, 5];

for (let i = 0; i < 9; i++) {
  while (i >= 0 && unsorted[i] > unsorted[i + 1]) {
    let temp = unsorted[i];
    unsorted[i] = unsorted[i + 1];
    unsoted[i + 1] = temp;
    i--;
  }
}
```

# 퀵 정렬 (Quick sort)

* 퀵 정렬은 대표적인 분할 정복 알고리즘으로 특정 값을 기준으로 큰 숫자와 작은 숫자로 나누는 개념이다.(잘게 나눈 후 정렬 후 합치기)
* 특정값, 기준값은 피벗이라고 함
* 시간 복잡도 O(N * logN), 굉장히 연산 속도 빠르고 효율적
* 이미 거의 정렬되어 있는 상태면 최악의 시간 복잡도 O(N*2)이 됨
* 정렬할 데이터 특성에 맞게 적절한 알고리즘을 사용하는 것이 바람직함, 일반적으론 퀵정렬이 빠르지만 거의 정렬되어 있는 data라면 삽입정렬이 더 빠름 
### JS코드
```
const unsorted = [10, 2, 5, 8, 6, 1, 4, 7, 3, 9];

function quickSort (data, start, end) {
  if (start >= end) {
    return;
  }

  let i = start + 1;
  let j = end;
  let key = start;
  let temp;

  while (i <= j) { //엇갈릴때 까지 반복
    while (i <= end && data[i] <= data[key]) { // 키 값보다 큰 값 찾기 -> 처음부터(키 바로 옆에서 부터)
      i++;
    }
    while (j > start && data[j] >= data[key]) { // 키값보다 작은 값 찾기 <- 끝에서부터
      j--;
    }

    if (i > j) { // 엇갈리면(key값보다 작거나 큰값이 없을 때) 키 값과 작은값 교체
      temp = data[j];
      data[j] = data[key];
      data[key] = temp;
    } else { // 엇갈리지 않으면, key값보다 작거나 큰값을 있을 경우
      temp = data[j];
      data[j] = data[i];
      data[i] = temp;
    }
  }

  quickSort(data, start, j - 1);
  quickSort(data, j + 1, end);
}
```


# 병합 정렬 (Merge Sort)

* 퀵정렬은 피벗값에 따라 편향된 분할결과를 만들 수도 있지만, 병합정렬은 최악의 경우에도 O(N * logN) 보장
* 일단 반으로 나누고 나중에 합치는 개념 (합치면서 정렬)
* 너비가 N, 높이가 logN
* 기존의 데이터를 담을 추가적인 배열 공간이 필요해서 메모리 활용이 비효율적임


### JS코드 구현
```
const unsorted = [3, 7, 2, 1, 5, 4, 5, 8];
const sorted = [];

mergeSort(unsorted, 0, unsorted.length - 1);

function merge (arr, start, middle, end) {
  let i = start;
  let j = middle + 1;
  let k = start;

  while (i <= middle && j <= end) { //i는 왼쪽에서부터, j는 중간부터 서로 크기 비교 후 sorted에 정렬
    if (arr[i] <= arr[j]) {
      sorted[k] = arr[i];
      i++;
    } else {
      sorted[k] = arr[j];
    }
    k++;
  }

  if (i > middle) { // 나머지 남은 배열 정렬
      for (let t = j; t <= end; t++) {
        sorted[k] = arr[t];
        k++;
      }
    } else {
      for (let t = i; t <= middle; t++) {
        sorted[k] = arr[t];
        k++;
      }
    }

    for (let t = start; t <= end; t++) { // 원래 arr에 sorted복사
      arr[t] = sorted[t];
    }
}

function mergeSort(arr, start, end) { // 재귀로 나타내기
  if (start < end) {
    let middle = parseInt((start + end) / 2);
    mergeSort(arr, start, middle);
    mergeSort(arr, middle + 1, end);
    merge(arr, start, middle, end);
  }
}

```

# 힙 정렬 (Heap sort)

* 힙 트리 구조를 이용하는 정렬 방식으로 이진트리와 힙에 대한 이해 필요
* 이진 트리는 모든 노드의 자식노드가 2개 이하인 노드이고, 완전 이진트리는 이진 트리의 노드가 중간에 비어있지 않고 빽빽한 구조
* 힙 트리는 완전 이진 트리를 기반으로 하는 트리로, 최댓값과 최솟값을 빠르게 찾기 위한 용도로 사용
* 트리는 가지를 뻗어가는 것 처럼 데이터가 서로 연결된 것
* 최대 힙은 부모노드가 자식노드보다 큰 힙
* 힙생성 알고리즘은 특정한 노드의 두 자식 중 더 큰 자식과 자신의 위치를 바꾸는 알고리즘, 이 특정노드를 제외하고는 최대 힙이 구성된 상태를 가정
* 별도의 메모리 사용이 없어서 효율적, 항상 O(N * logN) 보장

### JS코드
```
const N = 9;
const heap = [7, 6, 5, 8, 3, 5, 9, 1, 6];

for (let i = 1; i < N; i++) {
  let c = i;
  do {
    let root = (c - 1) / 2;
    if (heap[root] < heap[c]) {
      let temp = heap[root];
      heap[root] = heap[c];
      heap[c] = temp;
    }
    c = root;
  } while (c !== 0);
}

for (let i = N - 1; i >= 0; i--) {
  let temp = heap[0];
  heap[0] = heap[i];
  heap[i] = temp;
  
  let root = 0;
  let c = 1;
  do {
    c = 2 * root + 1;
    if (c < i - 1 && heap[c] < heap[c + 1]) {
      c++;
    }

    if (c < i && heap[root] < heap[c]) {
      let temp = heap[root];
      heap[root] = heap[c];
      heap[c] = temp;
    }
    root = c;
  } while (c < i);
}
```


# 계수 정렬 (Counting Sort)

* 범위 조건이 있는 경웨서 굉장히 빠른 알고리즘
* 크기를 기준으로 갯수를 세는 개념
* 데이터의 크기가 한정되어 있을 때만 사용 가능
* 시간 복잡도 O(N)

### JS코드
```
const N = 5;
const unsorted = [
  2, 3, 1, 4, 5, 2, 1, 2, 1, 4,
  5, 5, 3, 3, 2, 4, 3, 1, 2, 1,
  4, 4, 3, 2, 2, 1, 4, 3, 2, 5
]
const sorted = new Array(N).fill(0);

for (let i = 0; i < unsorted.length; i++) {
  sorted[unsorted[i] - 1]++;
}

let answer = "";

for (let i = 0; i < N; i++) {
  for (let j = 0; j < sorted[i]; j++) {
    answer += String(i + 1);
  }
}

```

# 스택 (Stack)과 큐 (Queue)

## 스택 (Stack)

* 가장 기본이 되는 자료 구조인 스택과 큐
* 자료 구조란 자료를 표현하고 처리하는 방법에 관한 것
* 알고리즘은 이런 자료 구조를 이용해서 문제를 해결하는 방법
* 스택은 가장 먼저 들어간 것이 가장 나중에 나가는 형태

### JS코드
```
const stack = [];

stack.push(4);
stack.push(5);
stack.push(2);
stack.pop();
stack.push(7);
stack.pop();
stack.pop();
stack.push(1);

console.log(stack) // 4, 1

```

## 큐 (Queue)

* 가장 먼저 들어온 것이 가장 먼저 나가는 구조
* 양 옆이 뚫린 터널 구조

### JS코드
```
const queue = [];

queue.push(2);
queue.push(7);
queue.push(4);
queue.shift();
queue.push(8);
queue.shift();
queue.push(1);

console.log(queue) // 4, 8, 1
```


# 너비 우선 탐색 (BFS, Breadth First Search)

* 탐색을 할 때 너비를 우선으로 하여 탐색을 수행하는 탐색 알고리즘
* 시작점을 기준으로 가까운 곳부터 탐색
* 맹목적인 탐색을 하고자 할때 사용할 수 있는 탐색 기법
* 최단경로를 찾아줌, 최단 길이를 보장할 때 많이 사용 (웹 크롤링, 가비지 컬렉션 등) 
* 큐를 필요로 함
* 작동 방식
  * 큐에서 하나의 노드를 꺼냄
  * 해당 노드에 연결된 노드 중 방문하지 않은 노드를 방문하고, 차례대로 큐에 삽입
  * 위 과정 반복
* 너비 우선 탐색 알고리즘 자체보단 다른 알고리즘에 적용되어 효과적으로 사용되는 것에 의미가 있다
* 장점  - 답이 되는 경로가 여러 개인 경우 최단경로임을 보장, 최단경로가 존재하면 깊이가 깊어져도 찾을 수 있음
* 단점 - 경로가 길 경우 메모리 사용 많아짐, 해가 존재하지 않거나 무한 그래프라면 결과가 안나옴

### JS코드
```
const graph = {
  1 : [2, 3],
  2 : [1, 3, 4, 5],
  3 : [1, 2, 6, 7],
  4 : [2, 5],
  5 : [2, 6],
  6 : [3, 7],
  7 : [3, 6]
}

const bfs = (graph, startNode) => {
  let checked = []; // 탐색된 노드들
  let unchecked = []; // 탐색해야될 노드들

  unchecked.push(startNode); //노드 탐색 시작

  while (unchecked.length !== 0) { //탐색할 노드가 남았다면
    const node = unchecked.shift(); 
    if (!checked.includes(node)) { // 해당 노드가 탐색된 적이 없다면
      checked.push(node);
      unchecked = [...unchecked, ...graph[node]];
    }
  }
  return checked
}
// result 1, 2, 3, 4, 5, 6, 7
```


# 깊이 우선 탐색 (DFS, Depth First Search)

* 최대한 깊이 내려가고 더이상 깊이 갈 곳이 없을 때까지 탐색 후 옆으로 이동
* 한 개의 큐와 스택을 이용
* DFS자체로의 의미모단, DFS를 이용한 그래프 알고리즘을 구현하여 활용적인 목적에 의미가 있다
* 작동 방식
  * 스택에 시작 노드를 넣는다
  * 스택이 비었으면 실행을 멈추고 false 반환
  * 스택의 맨 위 노드가 찾고자 하는 노드라면 탐색 종료 후 true 반환
  * 앞 단계에서 스택의 맨위 노드가 찾고자 하는 노드가 아니면 해당 노드를 pop하고, 스택에 들어온 적이 없는 pop한 노드의 모든 이웃 노드를 찾아 스택에 넣는다.
  * step3로 돌아감 반복
* 장점 - 현 경로상 노드를 기억하기 때문에 적은 메모리 사용, 찾으려는 노드가 깊은 단계에 있는 경우엔 BFS보다 빠르게 찾음
* 단점 - 해가 없는 경로를 탐색할 경우 끝날 때까지 탐색, DFS로 얻은 결과가 최단 경로라는 보장 없음, 비효율성


### JS코드
```
const graph = {
  1 : [2, 3],
  2 : [1, 3, 4, 5],
  3 : [1, 2, 6, 7],
  4 : [2, 5],
  5 : [2, 6],
  6 : [3, 7],
  7 : [3, 6]
}

const dfs = (graph, startNode) => {
  const checked = [];
  let unchecked = []
  
  unchecked.push(startNode);
  while (unchecked.length !== 0) {
    const node = unchecked.shift();
    if (!checked.includes(node)) {
      checked.push(node);
      unchecked = [...graph[node], ...unchecked]; // 스택구조로 먼저 쌓임 
    }
  }

  return checked;
}

// [1, 2, 3, 6, 7, 4, 5]
```
// dfs, bfs는 Convenant 블로그 참조


# Union-Find (합집합 찾기)

* 대표적인 그래프 알고리즘으로, 여러 개의 노드가 존재할 때 두 개의 노드를 선택해서, 현재 이 두 노드가 서로 같은 그래프에 속하는지 판별하는 알고리즘
* 서로 다른 두 노드가 연결되어 있을 땐 더 작은 값쪽으로 합칩니다.
* Union-Find 알고리즘은 다른 고급 그래프 알고리즘의 베이스가 됨

### JS코드
```
const parent = [];
for (let i = 0; i <= 10 i++) {
  parent[i] = i;
}

function getParent(arr, index) {
  if (arr[index] = index) return index;
  return arr[index] = getParent(arr, arr[index])
}

function unionParent(arr, a, b) {
  a = getParent(arr, a);
  b = getParent(arr, b);
  if (a < b) {
    arr[b] = a;
  } else {
    arr[a] = b;
  }
}

function findParent(arr, a, b) {
  a = getParent(arr, a);
  b = getParent(arr, b);

  if (a === b) {
    return true;
  } else {
    return false;
  }
}

unionParent(parent, 1, 2);
unionParent(parent, 2, 3);
unionParent(parent, 3, 4)
unionParent(parent, 5, 6)
unionParent(parent, 6, 7)
unionParent(parent, 7, 8)
console.log(findParent(parent, 1, 5)) // false;
unionParent(parent, 1, 5)
console.log(findParent(parent, 1, 5)) // true;
```

# Kruskal Algorithm (크루스칼 알고리즘)

* 가장 적은 비용으로 모든 노드를 연결하는 알고리즘, Union-Find를 이용, 최소 신장 트리(Minimal Spanning Tree)구하는 알고리즘
* 노드 - 정점, 간선 = 거리, 비용, 즉 두 노드 사이 관계 선
* 두 노드 사이 간선 거리(비용)가 짧은 순서대로 그래프에 포함시키기
* 간선 정보를 오름차순으로 정렬한 후, 비용이 적은 간선부터 차례 대로 그래프에 포함, 이때 사이클(순환 고리)이 형성되지 않도록


### JS코드
```
const parent = [];
for (let i = 0; i <= 7; i++) {
  parent[i] = i;
}

function getParent(arr, index) {
  if (arr[index] === index) return index;
  return arr[index] = getParent(arr, arr[index])
}

function unionParent(arr, a, b) {
  a = getParent(arr, a);
  b = getParent(arr, b);
  if (a < b) {
    arr[b] = a;
  } else {
    arr[a] = b;
  }
}

function findParent(arr, a, b) {
  a = getParent(arr, a);
  b = getParent(arr, b);

  if (a === b) {
    return true;
  } else {
    return false;
  }
}

// 동일하게 Union-Find를 이용
const costList = [[1, 7, 12], [1, 4, 28], [1, 2, 67], [1, 5, 17], [2, 4, 24], [2, 5, 62], [3, 5, 20], [3, 6, 37], [4, 7, 13], [5, 6, 45], [5, 7, 73]];

costList.sort((a, b) => a[2] > b[2]); // 오름차순으로 정리

let answer = 0;

for (let cost of costList) {
  if (!findParent(parent, cost[0], cost[1])) { //서로 연결 안되어있으면
    answer += cost[2];
    unionParent(parent, cost[0], cost[1]) // 서로 연결
  }
}
```

# 이진 트리의 구현과 순회방식

* 비선형 자료구조에서 가장 많이 사용되는 이진 트리, 데이터의 탐색 속도 증진을 위해 주로 사용, 포인터와 트리로 구성
* 포인터를 이용해서 완전 이진 트리가 아니더라도 안정적으로 노드들을 가르킬 수 있음
* 데이터 탐색 방식
  * 전위 순회 (Preorder Traversal) - 자신 -> 왼쪽 -> 오른쪽
  * 중위 순회 (Inorder Traversal) - 왼쪽 -> 자신 -> 오른쪽
  * 후위 순회 (Postorder Traversal) - 왼쪽 -> 오른쪽 -> 자신

### JS코드
```
class BinarySearchTree {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }

  insert(value) {
    if (value < this.value) { //새로 들어온 value가 이 트리에 원래있던 this.value보다 작으면 왼쪽으로 먼저 들어감
      if (this.left === null) { // 왼쪽 비었으면
        this.left = new BinarySearchTree(vale);
      } else {
        this.left.insert(value); //안 비었을 때는 왼쪽의 자식노드로 insert함수 재귀
      }
    } else if (value > this.value) { // 새로들어온 value가 더 크면 오른쪽으로
        if (this.right === null) {
          this.right = new BinarySearchTree(value);
        } else {
          this.right.insert(value);
        }
    } else {
      // 이미 포함되어있는 경우
    }
  }

  contain(value) {
    if (value === this.value) {
      return true;
    }

    if (value < this.value) {
      return !!(this.left && this.left.contain(value)) // 작으면 왼쪽 확인, left있나 확인 후 contain함수로 확인
    }

    if (value > this.value) {
      return !!(this.right && this.right.contain(value));
    }
  }

  preorder(callback) { // 자신 -> 왼 -> 오
    callback(this.value);
    if (this.left) {
      this.left.preorder(callback);
    }
    if (this.right) {
      this.right.preorder(callback)
    }
  }

  inorder(callback) { // 왼 -> 자신 -> 오
    if (this.left) {
      this.left.inorder(callback);
    }
    callback(this.value);
    if (this.right) {
      this.right.inorder(callback);
    }
  }

  postorder(callback) { // 왼 -> 오 -> 자신
    if (this.left) {
      this.left.postorder(callback);
    }
    if (this.right) {
      this.right.postorder(callback);
    }
    callback(this.value);
  }
}
```

# 다이나믹 프로그래밍 (Dynamic Programming)

* 하나의 문제는 단 한 번만 풀도록 하는 알고리즘
* 두 가지 가정
  * 큰 문제를 작은 문제로 나눌 수 있음
  * 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일
* 크고 어려운 문제를 잘게 나누어 해결한 뒤 처리한 후 나중에 전체의 답을 구하는 것
* 시간 복잡도는 O(N) 


### JS코드
```
const dp = [0]; // 피보나치 예시

let fibonacci = (n) => { // 처음에 함수 선언식으로 했다가 에러발생 변경 jakeseo velog 참조
  if (n < 3) {
    dp[n] = 1;
  }
  if (!dp[n]) { //값이 없다면 피보나치 재귀함수로 값 저장
    dp[n] = fibonacci(n - 1) + fibonacci(n - 2);
  }

  return dp[n];
}

```

# 에라토스테네스의 체

* 대표적인 소수 판별 알고리즘 중 소수를 대량으로 빠르고 정확하게 구하는 방법
* 구현 단계
  * 소수를 판별할 범위만큼 배열을 할당하고 인덱스에 해당 값을 넣는다.
  * 2부터 시작해서 특정 숫자의 배수에 해당하는 수들은 지운다.
  * 남아있는 수들을 출력


### JS코드
```
function primeNumberSieve(n) {
  const primes = new Array(n);
  
  for (let i = 0; i <= n; i++) {
    primes[i] = i;
  }

  for (let i = 2; i * i <= n; i++) {
    if (primes[i] !== 0) {
      let k = 2;
      while (i * k <= n) { // 배수들 제거하기
        primes[i * k] = 0;
        k++;
      }
    }
  }

  return primes;
}

```

# 다익스트라 알고리즘 (Dijkstar Algorithm)

* 다이나믹 프로그래밍을 활용한 대표적인 최단 경로탐색 알고리즘
* 특정한 하나의 정점에서 다른 모든 정점으로 가는 최단 경로 알려줌
* 다이나믹 프로그래밍을 활용한 방식은 최단 거리가 여러 개의 최단 거리로 이루어져 있는 것을 이용, 하나의 최단 거리를 구할 때 그 이전까지 구했던 최단 거리 정보를 그대로 사용
* 구현과정
  * 출발 노드 설정
  * 출발 노드 기준 각 노드의 최소 비용 저장
  * 방문하지 않은 노드(출발 노드 제외 나머지 노드) 중에서 가장 비용이 적은 노드를 선택
  * 해당 노드를 거쳐 특정한 노드로 가는 경우를 고려하여 최소 비용 갱신
  * 3 ~ 4번 과정 반복
* 단점 - 시간복잡도 O(N^2), N은 꼭짓점의 갯수

### JS구현
```
const INF = Infinity;
const arr = [
  [0, 2, 5, 1, INF, INF],
  [2, 0, 3, 2, INF, INF],
  [5, 3, 0, 3, 1, 5],
  [1, 2, 3, 0, 1, INF],
  [INF, INF, 1, 1, 0, 2],
  [INF, INF, 5, INF, 2, 0]
]
const visited = new Array(6).fill(false);

const getSmallIndex = function(vertex) {
  let min = INF;
  let idx = 0;
  for (let i = 0; i< vertex.length; i++) {
    if (min > vertex[i] && !visited[i]) {
      min = vertex[i];
      idx = i;
    }
  }
  
  return idx;
}

const dist = function(start) {
  let v = arr[start - 1];
  let count = 0;
  let end = v.length;
  let min = 0;
  let startV = v;
  visited[start - 1] = true;
  
  while (count < end) {
    const idx = getSmallIndex(startV);
    min += startV[idx];
    const next = arr[idx];
    for (let i = 0; i< v.length; i++) {
      if (v[i] > next[i] + min && !visited[i]) {
        v[i] = next[i] + min;
      }
    }
    
      startV = arr[idx];
      visited[idx] = true;
      count++;
  }
  console.log(v);
}

dist(1);
// 천유린 개발블로그 참조
```

* 최소 힙에 기반한 다익스트라 알고리즘
* 인접 리스트를 이용
// 이해 못함, 좀 더 공부 후 적기
### JS구현
```
```

# 플로이드 와샬 알고리즘 (Floyd Warshall Algorithm)

* 모든 정점에서 모든 정점으로의 최단 경로 
* 다이나믹 프로그래밍 기술에 의거함
* 알고리즘의 핵심 아이디어는 거쳐가는 정점을 기준으로 최단거리를 구하기 (x에서 y로 가는 비용 vs  x에서 z노드 가는 비용 + z노드에서 y가는 비용)
* 시간 복잡도 O(N^3)으로 비효율적이나 모든 경로 최단 거리 구할 수 있음

### JS코드
```
const graph = [
  [0, 5, INF, 8],
  [7, 0, 9, INF],
  [2, INF, 0, 4],
  [INF, INF, 3, 0]
]

const floydWarshall = (dist) => {
  const N = dist.length;


  //i는 거쳐가는 노드
  for (let i = 0; i < N; i++) {
    // j는 출발 노드
    for (let j = 0; j < N; j++) {
      // k는 도착 노드
      for (let k = 0; k < N; k++) {
        if (dist[j][i] + dist[i][k] < dist[j][k]) {
          dist[j][k] = dist[j][i] + dist[i][k];
        }
      }
    }
  }

  return dist;
}

floydWarshall(graph);
// result [[0, 5, 11, 8], [7, 0, 9, 13], [2, 7, 0, 4], [5, 10, 3, 0]] 
```

# 위상 정렬 (Topology Sort)

* 순서가 정해져있는 작업을 차례대로 수행해야 할 때  순서를 결정해주기 위해 사용하는 알고리즘
* 사이클이 발생하지 않는 방향 그래프에서만 적용 가능
* 두 가지 해결책 도출
  * 현재 그래프가 위상 정렬이 가능한지
  * 가능하면 결과가 무엇인지
* 스택을 이용하는 방식과 큐를 이용한 방식이 있다.
* 구현 과정 (큐 사용)
  * 진입차수가 0인 정점을 큐에 삽입
  * 큐에서 원소를 꺼내 연결된 모든 간선을 제거
  * 간선 제거 이후에 진입차수가 0이 된 정점을 큐에 삽입
  * 큐가 빌때 까지 2~3 과정 반복
  * 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재하는 것이고, 모든 원소를 방문했다면 큐에서 꺼낸 순서가 위상 정렬의 결과이다.
* 시간 복잡도 O(V + E) V는 노드 개수, E는 간선의 개수

### JS구현
```
const N = 7;
const graph = [0, [2, 5], [3], [6], [6], [7], []];
const inDegree = new Array(N + 1).fill(0);
for (let i = 1; i < graph.length; i++) {
  const node = graph[i];
  for (let j = 1; j < node.length; j++) {
    inDegree[node[j]]++;
  }
}

const queue = [];
for (let i = 1; i <= N; i++) {
  if (!inDegree[i]) {
    queue.push(i);
  }
}

const result = [];
while (queue.length) {
  const n = queue.pop(); // 큐에서 제거
  result.push(n);
  graph[n].forEach(v => { 
    inDegree[v]--;  //다음 노드 degree 하나 줄이고
    if (!inDegree[v]) { // 다음 노드 degree가 0이라면 queue에 넣기
      queue.push(v);
    }
  });
}

console.log(result) // 1 5 2 3 4 6 7
```


# 강한 결합 요소 (Strongly Connected Component)

* 강한 결합 요쇼란 강하게 결합된 정점의 집합으로, 사이클을 이루는 정점들의 집합이다. 같은 SCC에 속하는 두 정점은 서로 도달이 가능하다. 
* 정점들 사이 경로가 항상 존재 하지만, 한 방향 경로만 존재 (a -> b ok, b -> a no)
* SCC를 추출하는 대표적인 알고리즘으로 코사라주 알고리즘(Kosaraju's Algorithm)과 타잔 알고리즘(Tarjan's Algorithm)
* 코사라주 알고리즘이 구현이 쉬움, 타잔 알고리즘은 적용이 쉬움
* 타잔 알고리즘은 dfs를 적용하여 방문한 노드들을 스택에 저장하면서 강한 결합 요소를 찾는 알고리즘이다.
* 강한 결합 요소 그 자체로는 의미가 없고, 위상 정렬과 함께 생각할 때 큰 의미가 있음
* 강한 결합 요소의 타잔 알고리즘의 시간 복잡도 O(V + E)

### JS구현
```
const graph = [
  0,
  [2],
  [3],
  [1],
  [2, 5],
  [7],
  [5],
  [6]
]
const isVisited = new Array(8).fill(false);
const isFinished = new Array(8).fill(false);
const stack = [];
const scc = [];

const dfs = (vertex) => {
  let parent = vertex;
  isVisited[vertex] = true;
  stack.push(vertex);
  
  for (let i =0; i < graph[vertex].length; i++) {
    const nextVertex = graph[vertex][i];
    if (!isVisited[nextVertex]) {
      parent = Math.min(parent, dfs(nextVertex)); // 여기서 재귀, 사이클 돌면서 시작, 가장 작은 노드 구함
    } else if (!isFinished[nextVertex]) {
      parent = nextVertex;
    }
  }

  if (parent === vertex) { // stack에 1, 2, 3 쌓이고 (처음 기준)
    const sccElement = [];
    let topElement = 0;
    do {
      topElement = stack.pop();
      isFinished[topElement] = true;
      sccElement.unshift(topelement); // srcElement에 3, 2, 1 쌓임
    } while (topElement !== parent);
    scc.push(sccEl); //scc 에 [3, 2, 1] push
  }

  return parent;
}

const tarjan = () => {
  let parent = 0;
  let topElement = 0;
  for (let vertex = 1; vertex < graph.length; vertex++) {
    if (!isFinished[vertex]) {
      dfs(vertex);
    }
  }
}

tarjan();
console.log(scc);
// 천유린 블로그 참조
```

# 네트워크 플로우 (Network Flow)

* 특정한 지점에서 다른 지점으로 데이터가 얼마나 흐르는지 측정하는 알고리즘 (교통 체증, 네트워크 데이터 전송 등에서 활용)
* 네트워크 플로우 알고리즘의 핵심 아이디어는 최대 유량 문제로 생각할 수 있음 
* 최대 유량문제란, 각 간선에 정해진 용량이 있을 때 최대로 보낼 수 있는 유량 크기
* BFS를 이용한 에드몬드 카프 알고리즘 사용
* 남아있는 모든 가능한 경로를 다 찾기 위해 음의 유량을 계산해줌, 유량이 지나가는 반대 방향의 유량
* 에드몬드 카프 알고리즘의 시간 복잡도는 O(VE^2)

### JS구현  
```
//아직 모르겠다. c++ -> js 구현은
```