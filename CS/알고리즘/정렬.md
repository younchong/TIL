# 선택 정렬 (Selection Sort)

* 가장 직관적이고 구현하기 쉬움 (가장 작은것을 제일 앞으로 보낸다)
* 시간 복잡도 O(N^2)
* 다른 알고리즘 비교 비효율적이고 느린 알고리즘

### JS코드
```
const unsorted = [2, 7, 1, 3, 6, 8, 10, 5, 9, 4];

for (let i = 0; i < 10; i++) {
  let temp;
  let index;
  let min = 999;
  for (let j = i; j < 10; j++) {
    if (min > unsorted[j]) {
      min = unsorted[j];
      index = j
    }
  }

  temp = unsorted[i]; // 최솟값과 교환될 값
  unsorted[i] = unsorted[index]; // 최솟값이 맨 앞으로 이동
  unsorted[index] = temp; // 원래 최솟값있던 자리랑 교환
}
```

# 버블 정렬 (Bubble Sort)

* 옆에 있는 값과 비교해서 자리 바꾸기
* 간단하고 직관적
* 가장 효율이 떨어지고 느림 (매번 교체를 해서)
* 시간 복잡도 O(N^2)  (같은 시간복잡도라도 위와 같은 이유로 실제로는 더 느림)

### JS코드
```
const unsorted = [2, 3, 10, 8, 1, 5, 7, 4, 6, 9];

for (let i = 0; i < 10; i++) {
  for (let j = 0; j < 9 - i; j++) {
    if (unsorted[j] > unsorted[j + 1]) {
      let temp = unsorted[j];
      unsorted[j] = unsorted[j + 1];
      unsorted[j + 1] = temp;
    }
  }
}
```

# 삽입 정렬 (Insertion Sort)

* 삽입 정렬은 숫자를 적절한 위치에 삽입하는 알고리즘으로, 필요할 때만 위치를 변경
* 앞의 두 정렬과 비교해선 제일 빠르고, 효율적 (연산이 적음)
* 정렬이 되어있다고 가정 한다는 점에서 특정한 경우에 굉장히 빠름
* 거의 정렬된 상태라면 삽입정렬이 가장 효율적이고 빠름
* 시간 복잡도 O(N^2) (그래도 위의 이유로 앞 선 두 정렬보단 빠름)

### JS코드
```
const unsorted = [10, 2, 1, 8, 6, 3, 9, 4, 7, 5];

for (let i = 0; i < 9; i++) {
  while (i >= 0 && unsorted[i] > unsorted[i + 1]) {
    let temp = unsorted[i];
    unsorted[i] = unsorted[i + 1];
    unsoted[i + 1] = temp;
    i--;
  }
}
```

# 퀵 정렬 (Quick sort)

* 퀵 정렬은 대표적인 분할 정복 알고리즘으로 특정 값을 기준으로 큰 숫자와 작은 숫자로 나누는 개념이다.(잘게 나눈 후 정렬 후 합치기)
* 특정값, 기준값은 피벗이라고 함
* 시간 복잡도 O(N * logN), 굉장히 연산 속도 빠르고 효율적
* 이미 거의 정렬되어 있는 상태면 최악의 시간 복잡도 O(N*2)이 됨
* 정렬할 데이터 특성에 맞게 적절한 알고리즘을 사용하는 것이 바람직함, 일반적으론 퀵정렬이 빠르지만 거의 정렬되어 있는 data라면 삽입정렬이 더 빠름 
### JS코드
```
const unsorted = [10, 2, 5, 8, 6, 1, 4, 7, 3, 9];

function quickSort (data, start, end) {
  if (start >= end) {
    return;
  }

  let i = start + 1;
  let j = end;
  let key = start;
  let temp;

  while (i <= j) { //엇갈릴때 까지 반복
    while (i <= end && data[i] <= data[key]) { // 키 값보다 큰 값 찾기 -> 처음부터(키 바로 옆에서 부터)
      i++;
    }
    while (j > start && data[j] >= data[key]) { // 키값보다 작은 값 찾기 <- 끝에서부터
      j--;
    }

    if (i > j) { // 엇갈리면(key값보다 작거나 큰값이 없을 때) 키 값과 작은값 교체
      temp = data[j];
      data[j] = data[key];
      data[key] = temp;
    } else { // 엇갈리지 않으면, key값보다 작거나 큰값을 있을 경우
      temp = data[j];
      data[j] = data[i];
      data[i] = temp;
    }
  }

  quickSort(data, start, j - 1);
  quickSort(data, j + 1, end);
}
```


# 병합 정렬 (Merge Sort)

* 퀵정렬은 피벗값에 따라 편향된 분할결과를 만들 수도 있지만, 병합정렬은 최악의 경우에도 O(N * logN) 보장
* 일단 반으로 나누고 나중에 합치는 개념 (합치면서 정렬)
* 너비가 N, 높이가 logN
* 기존의 데이터를 담을 추가적인 배열 공간이 필요해서 메모리 활용이 비효율적임


### JS코드 구현
```
const unsorted = [3, 7, 2, 1, 5, 4, 5, 8];
const sorted = [];

mergeSort(unsorted, 0, unsorted.length - 1);

function merge (arr, start, middle, end) {
  let i = start;
  let j = middle + 1;
  let k = start;

  while (i <= middle && j <= end) { //i는 왼쪽에서부터, j는 중간부터 서로 크기 비교 후 sorted에 정렬
    if (arr[i] <= arr[j]) {
      sorted[k] = arr[i];
      i++;
    } else {
      sorted[k] = arr[j];
    }
    k++;
  }

  if (i > middle) { // 나머지 남은 배열 정렬
      for (let t = j; t <= end; t++) {
        sorted[k] = arr[t];
        k++;
      }
    } else {
      for (let t = i; t <= middle; t++) {
        sorted[k] = arr[t];
        k++;
      }
    }

    for (let t = start; t <= end; t++) { // 원래 arr에 sorted복사
      arr[t] = sorted[t];
    }
}

function mergeSort(arr, start, end) { // 재귀로 나타내기
  if (start < end) {
    let middle = parseInt((start + end) / 2);
    mergeSort(arr, start, middle);
    mergeSort(arr, middle + 1, end);
    merge(arr, start, middle, end);
  }
}

```

# 힙 정렬 (Heap sort)

* 힙 트리 구조를 이용하는 정렬 방식으로 이진트리와 힙에 대한 이해 필요
* 이진 트리는 모든 노드의 자식노드가 2개 이하인 노드이고, 완전 이진트리는 이진 트리의 노드가 중간에 비어있지 않고 빽빽한 구조
* 힙 트리는 완전 이진 트리를 기반으로 하는 트리로, 최댓값과 최솟값을 빠르게 찾기 위한 용도로 사용
* 트리는 가지를 뻗어가는 것 처럼 데이터가 서로 연결된 것
* 최대 힙은 부모노드가 자식노드보다 큰 힙
* 힙생성 알고리즘은 특정한 노드의 두 자식 중 더 큰 자식과 자신의 위치를 바꾸는 알고리즘, 이 특정노드를 제외하고는 최대 힙이 구성된 상태를 가정
* 별도의 메모리 사용이 없어서 효율적, 항상 O(N * logN) 보장

### JS코드
```
const N = 9;
const heap = [7, 6, 5, 8, 3, 5, 9, 1, 6];

for (let i = 1; i < N; i++) {
  let c = i;
  do {
    let root = (c - 1) / 2;
    if (heap[root] < heap[c]) {
      let temp = heap[root];
      heap[root] = heap[c];
      heap[c] = temp;
    }
    c = root;
  } while (c !== 0);
}

for (let i = N - 1; i >= 0; i--) {
  let temp = heap[0];
  heap[0] = heap[i];
  heap[i] = temp;
  
  let root = 0;
  let c = 1;
  do {
    c = 2 * root + 1;
    if (c < i - 1 && heap[c] < heap[c + 1]) {
      c++;
    }

    if (c < i && heap[root] < heap[c]) {
      let temp = heap[root];
      heap[root] = heap[c];
      heap[c] = temp;
    }
    root = c;
  } while (c < i);
}
```


# 계수 정렬 (Counting Sort)

* 범위 조건이 있는 경웨서 굉장히 빠른 알고리즘
* 크기를 기준으로 갯수를 세는 개념
* 데이터의 크기가 한정되어 있을 때만 사용 가능
* 시간 복잡도 O(N)

### JS코드
```
const N = 5;
const unsorted = [
  2, 3, 1, 4, 5, 2, 1, 2, 1, 4,
  5, 5, 3, 3, 2, 4, 3, 1, 2, 1,
  4, 4, 3, 2, 2, 1, 4, 3, 2, 5
]
const sorted = new Array(N).fill(0);

for (let i = 0; i < unsorted.length; i++) {
  sorted[unsorted[i] - 1]++;
}

let answer = "";

for (let i = 0; i < N; i++) {
  for (let j = 0; j < sorted[i]; j++) {
    answer += String(i + 1);
  }
}

```

# 스택 (Stack)과 큐 (Queue)

## 스택 (Stack)

* 가장 기본이 되는 자료 구조인 스택과 큐
* 자료 구조란 자료를 표현하고 처리하는 방법에 관한 것
* 알고리즘은 이런 자료 구조를 이용해서 문제를 해결하는 방법
* 스택은 가장 먼저 들어간 것이 가장 나중에 나가는 형태

### JS코드
```
const stack = [];

stack.push(4);
stack.push(5);
stack.push(2);
stack.pop();
stack.push(7);
stack.pop();
stack.pop();
stack.push(1);

console.log(stack) // 4, 1

```

## 큐 (Queue)

* 가장 먼저 들어온 것이 가장 먼저 나가는 구조
* 양 옆이 뚫린 터널 구조

### JS코드
```
const queue = [];

queue.push(2);
queue.push(7);
queue.push(4);
queue.shift();
queue.push(8);
queue.shift();
queue.push(1);

console.log(queue) // 4, 8, 1
```


# 너비 우선 탐색 (BFS, Breadth First Search)

* 탐색을 할 때 너비를 우선으로 하여 탐색을 수행하는 탐색 알고리즘
* 시작점을 기준으로 가까운 곳부터 탐색
* 맹목적인 탐색을 하고자 할때 사용할 수 있는 탐색 기법
* 최단경로를 찾아줌, 최단 길이를 보장할 때 많이 사용 (미로찾기 알고리즘등)
* 큐를 필요로 함
* 작동 방식
  * 큐에서 하나의 노드를 꺼냄
  * 해당 노드에 연결된 노드 중 방문하지 않은 노드를 방문하고, 차례대로 큐에 삽입
  * 위 과정 반복
* 너비 우선 탐색 알고리즘 자체보단 다른 알고리즘에 적용되어 효과적으로 사용되는 것에 의미가 있다

### JS코드
```
const graph = {
  1 : [2, 3],
  2 : [1, 3, 4, 5],
  3 : [1, 2, 6, 7],
  4 : [2, 5],
  5 : [2, 6],
  6 : [3, 7],
  7 : [3, 6]
}

const bfs = (graph, startNode) => {
  let checked = []; // 탐색된 노드들
  let unchecked = []; // 탐색해야될 노드들

  unchecked.push(startNode); //노드 탐색 시작

  while (unchecked.length !== 0) { //탐색할 노드가 남았다면
    const node = unchecked.shift(); 
    if (!checked.includes(node)) { // 해당 노드가 탐색된 적이 없다면
      checked.push(node);
      unchecked = [...unchecked, ...graph[node]];
    }
  }
  return checked
}
// result 1, 2, 3, 4, 5, 6, 7
```