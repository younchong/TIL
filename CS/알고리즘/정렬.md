# 선택 정렬 (Selection Sort)

* 가장 직관적이고 구현하기 쉬움 (가장 작은것을 제일 앞으로 보낸다)
* 시간 복잡도 O(N^2)
* 다른 알고리즘 비교 비효율적이고 느린 알고리즘

### JS코드
```
const unsorted = [2, 7, 1, 3, 6, 8, 10, 5, 9, 4];

for (let i = 0; i < 10; i++) {
  let temp;
  let index;
  let min = 999;
  for (let j = i; j < 10; j++) {
    if (min > unsorted[j]) {
      min = unsorted[j];
      index = j
    }
  }

  temp = unsorted[i]; // 최솟값과 교환될 값
  unsorted[i] = unsorted[index]; // 최솟값이 맨 앞으로 이동
  unsorted[index] = temp; // 원래 최솟값있던 자리랑 교환
}
```

# 버블 정렬 (Bubble Sort)

* 옆에 있는 값과 비교해서 자리 바꾸기
* 간단하고 직관적
* 가장 효율이 떨어지고 느림 (매번 교체를 해서)
* 시간 복잡도 O(N^2)  (같은 시간복잡도라도 위와 같은 이유로 실제로는 더 느림)

### JS코드
```
const unsorted = [2, 3, 10, 8, 1, 5, 7, 4, 6, 9];

for (let i = 0; i < 10; i++) {
  for (let j = 0; j < 9 - i; j++) {
    if (unsorted[j] > unsorted[j + 1]) {
      let temp = unsorted[j];
      unsorted[j] = unsorted[j + 1];
      unsorted[j + 1] = temp;
    }
  }
}
```

# 삽입 정렬 (Insertion Sort)

* 삽입 정렬은 숫자를 적절한 위치에 삽입하는 알고리즘으로, 필요할 때만 위치를 변경
* 앞의 두 정렬과 비교해선 제일 빠르고, 효율적 (연산이 적음)
* 정렬이 되어있다고 가정 한다는 점에서 특정한 경우에 굉장히 빠름
* 거의 정렬된 상태라면 삽입정렬이 가장 효율적이고 빠름
* 시간 복잡도 O(N^2) (그래도 위의 이유로 앞 선 두 정렬보단 빠름)

### JS코드
```
const unsorted = [10, 2, 1, 8, 6, 3, 9, 4, 7, 5];

for (let i = 0; i < 9; i++) {
  while (i >= 0 && unsorted[i] > unsorted[i + 1]) {
    let temp = unsorted[i];
    unsorted[i] = unsorted[i + 1];
    unsoted[i + 1] = temp;
    i--;
  }
}
```