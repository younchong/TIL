# 선택 정렬 (Selection Sort)

* 가장 직관적이고 구현하기 쉬움 (가장 작은것을 제일 앞으로 보낸다)
* 시간 복잡도 O(N^2)
* 다른 알고리즘 비교 비효율적이고 느린 알고리즘

### JS코드
```
const unsorted = [2, 7, 1, 3, 6, 8, 10, 5, 9, 4];

for (let i = 0; i < 10; i++) {
  let temp;
  let index;
  let min = 999;
  for (let j = i; j < 10; j++) {
    if (min > unsorted[j]) {
      min = unsorted[j];
      index = j
    }
  }

  temp = unsorted[i]; // 최솟값과 교환될 값
  unsorted[i] = unsorted[index]; // 최솟값이 맨 앞으로 이동
  unsorted[index] = temp; // 원래 최솟값있던 자리랑 교환
}
```

# 버블 정렬 (Bubble Sort)

* 옆에 있는 값과 비교해서 자리 바꾸기
* 간단하고 직관적
* 가장 효율이 떨어지고 느림 (매번 교체를 해서)
* 시간 복잡도 O(N^2)  (같은 시간복잡도라도 위와 같은 이유로 실제로는 더 느림)

### JS코드
```
const unsorted = [2, 3, 10, 8, 1, 5, 7, 4, 6, 9];

for (let i = 0; i < 10; i++) {
  for (let j = 0; j < 9 - i; j++) {
    if (unsorted[j] > unsorted[j + 1]) {
      let temp = unsorted[j];
      unsorted[j] = unsorted[j + 1];
      unsorted[j + 1] = temp;
    }
  }
}
```

# 삽입 정렬 (Insertion Sort)

* 삽입 정렬은 숫자를 적절한 위치에 삽입하는 알고리즘으로, 필요할 때만 위치를 변경
* 앞의 두 정렬과 비교해선 제일 빠르고, 효율적 (연산이 적음)
* 정렬이 되어있다고 가정 한다는 점에서 특정한 경우에 굉장히 빠름
* 거의 정렬된 상태라면 삽입정렬이 가장 효율적이고 빠름
* 시간 복잡도 O(N^2) (그래도 위의 이유로 앞 선 두 정렬보단 빠름)

### JS코드
```
const unsorted = [10, 2, 1, 8, 6, 3, 9, 4, 7, 5];

for (let i = 0; i < 9; i++) {
  while (i >= 0 && unsorted[i] > unsorted[i + 1]) {
    let temp = unsorted[i];
    unsorted[i] = unsorted[i + 1];
    unsoted[i + 1] = temp;
    i--;
  }
}
```

# 퀵 정렬 (Quick sort)

* 퀵 정렬은 대표적인 분할 정복 알고리즘으로 특정 값을 기준으로 큰 숫자와 작은 숫자로 나누는 개념이다.(잘게 나눈 후 정렬 후 합치기)
* 특정값, 기준값은 피벗이라고 함
* 시간 복잡도 O(N * logN), 굉장히 연산 속도 빠르고 효율적
* 이미 거의 정렬되어 있는 상태면 최악의 시간 복잡도 O(N*2)이 됨
* 정렬할 데이터 특성에 맞게 적절한 알고리즘을 사용하는 것이 바람직함, 일반적으론 퀵정렬이 빠르지만 거의 정렬되어 있는 data라면 삽입정렬이 더 빠름 
### JS코드
```
const unsorted = [10, 2, 5, 8, 6, 1, 4, 7, 3, 9];

function quickSort (data, start, end) {
  if (start >= end) {
    return;
  }

  let i = start + 1;
  let j = end;
  let key = start;
  let temp;

  while (i <= j) { //엇갈릴때 까지 반복
    while (i <= end && data[i] <= data[key]) { // 키 값보다 큰 값 찾기 -> 처음부터(키 바로 옆에서 부터)
      i++;
    }
    while (j > start && data[j] >= data[key]) { // 키값보다 작은 값 찾기 <- 끝에서부터
      j--;
    }

    if (i > j) { // 엇갈리면(key값보다 작거나 큰값이 없을 때) 키 값과 작은값 교체
      temp = data[j];
      data[j] = data[key];
      data[key] = temp;
    } else { // 엇갈리지 않으면, key값보다 작거나 큰값을 있을 경우
      temp = data[j];
      data[j] = data[i];
      data[i] = temp;
    }
  }

  quickSort(data, start, j - 1);
  quickSort(data, j + 1, end);
}
```


# 병합 정렬 (Merge Sort)

* 퀵정렬은 피벗값에 따라 편향된 분할결과를 만들 수도 있지만, 병합정렬은 최악의 경우에도 O(N * logN) 보장
* 일단 반으로 나누고 나중에 합치는 개념 (합치면서 정렬)
* 너비가 N, 높이가 logN
* 기존의 데이터를 담을 추가적인 배열 공간이 필요해서 메모리 활용이 비효율적임


### JS코드 구현
```
const unsorted = [3, 7, 2, 1, 5, 4, 5, 8];
const sorted = [];

mergeSort(unsorted, 0, unsorted.length - 1);

function merge (arr, start, middle, end) {
  let i = start;
  let j = middle + 1;
  let k = start;

  while (i <= middle && j <= end) { //i는 왼쪽에서부터, j는 중간부터 서로 크기 비교 후 sorted에 정렬
    if (arr[i] <= arr[j]) {
      sorted[k] = arr[i];
      i++;
    } else {
      sorted[k] = arr[j];
    }
    k++;
  }

  if (i > middle) { // 나머지 남은 배열 정렬
      for (let t = j; t <= end; t++) {
        sorted[k] = arr[t];
        k++;
      }
    } else {
      for (let t = i; t <= middle; t++) {
        sorted[k] = arr[t];
        k++;
      }
    }

    for (let t = start; t <= end; t++) { // 원래 arr에 sorted복사
      arr[t] = sorted[t];
    }
}

function mergeSort(arr, start, end) { // 재귀로 나타내기
  if (start < end) {
    let middle = parseInt((start + end) / 2);
    mergeSort(arr, start, middle);
    mergeSort(arr, middle + 1, end);
    merge(arr, start, middle, end);
  }
}

```

# 힙 정렬 (Heap sort)

* 힙 트리 구조를 이용하는 정렬 방식으로 이진트리와 힙에 대한 이해 필요
* 이진 트리는 모든 노드의 자식노드가 2개 이하인 노드이고, 완전 이진트리는 이진 트리의 노드가 중간에 비어있지 않고 빽빽한 구조
* 힙 트리는 완전 이진 트리를 기반으로 하는 트리로, 최댓값과 최솟값을 빠르게 찾기 위한 용도로 사용
* 트리는 가지를 뻗어가는 것 처럼 데이터가 서로 연결된 것
* 최대 힙은 부모노드가 자식노드보다 큰 힙
* 힙생성 알고리즘은 특정한 노드의 두 자식 중 더 큰 자식과 자신의 위치를 바꾸는 알고리즘, 이 특정노드를 제외하고는 최대 힙이 구성된 상태를 가정
* 별도의 메모리 사용이 없어서 효율적, 항상 O(N * logN) 보장

### JS코드
```
const N = 9;
const heap = [7, 6, 5, 8, 3, 5, 9, 1, 6];

for (let i = 1; i < N; i++) {
  let c = i;
  do {
    let root = (c - 1) / 2;
    if (heap[root] < heap[c]) {
      let temp = heap[root];
      heap[root] = heap[c];
      heap[c] = temp;
    }
    c = root;
  } while (c !== 0);
}

for (let i = N - 1; i >= 0; i--) {
  let temp = heap[0];
  heap[0] = heap[i];
  heap[i] = temp;
  
  let root = 0;
  let c = 1;
  do {
    c = 2 * root + 1;
    if (c < i - 1 && heap[c] < heap[c + 1]) {
      c++;
    }

    if (c < i && heap[root] < heap[c]) {
      let temp = heap[root];
      heap[root] = heap[c];
      heap[c] = temp;
    }
    root = c;
  } while (c < i);
}
```


# 계수 정렬 (Counting Sort)

* 범위 조건이 있는 경웨서 굉장히 빠른 알고리즘
* 크기를 기준으로 갯수를 세는 개념
* 데이터의 크기가 한정되어 있을 때만 사용 가능
* 시간 복잡도 O(N)

### JS코드
```
const N = 5;
const unsorted = [
  2, 3, 1, 4, 5, 2, 1, 2, 1, 4,
  5, 5, 3, 3, 2, 4, 3, 1, 2, 1,
  4, 4, 3, 2, 2, 1, 4, 3, 2, 5
]
const sorted = new Array(N).fill(0);

for (let i = 0; i < unsorted.length; i++) {
  sorted[unsorted[i] - 1]++;
}

let answer = "";

for (let i = 0; i < N; i++) {
  for (let j = 0; j < sorted[i]; j++) {
    answer += String(i + 1);
  }
}

```

# 스택 (Stack)과 큐 (Queue)

## 스택 (Stack)

* 가장 기본이 되는 자료 구조인 스택과 큐
* 자료 구조란 자료를 표현하고 처리하는 방법에 관한 것
* 알고리즘은 이런 자료 구조를 이용해서 문제를 해결하는 방법
* 스택은 가장 먼저 들어간 것이 가장 나중에 나가는 형태

### JS코드
```
const stack = [];

stack.push(4);
stack.push(5);
stack.push(2);
stack.pop();
stack.push(7);
stack.pop();
stack.pop();
stack.push(1);

console.log(stack) // 4, 1

```

## 큐 (Queue)

* 가장 먼저 들어온 것이 가장 먼저 나가는 구조
* 양 옆이 뚫린 터널 구조

### JS코드
```
const queue = [];

queue.push(2);
queue.push(7);
queue.push(4);
queue.shift();
queue.push(8);
queue.shift();
queue.push(1);

console.log(queue) // 4, 8, 1
```


# 너비 우선 탐색 (BFS, Breadth First Search)

* 탐색을 할 때 너비를 우선으로 하여 탐색을 수행하는 탐색 알고리즘
* 시작점을 기준으로 가까운 곳부터 탐색
* 맹목적인 탐색을 하고자 할때 사용할 수 있는 탐색 기법
* 최단경로를 찾아줌, 최단 길이를 보장할 때 많이 사용 (웹 크롤링, 가비지 컬렉션 등) 
* 큐를 필요로 함
* 작동 방식
  * 큐에서 하나의 노드를 꺼냄
  * 해당 노드에 연결된 노드 중 방문하지 않은 노드를 방문하고, 차례대로 큐에 삽입
  * 위 과정 반복
* 너비 우선 탐색 알고리즘 자체보단 다른 알고리즘에 적용되어 효과적으로 사용되는 것에 의미가 있다
* 장점  - 답이 되는 경로가 여러 개인 경우 최단경로임을 보장, 최단경로가 존재하면 깊이가 깊어져도 찾을 수 있음
* 단점 - 경로가 길 경우 메모리 사용 많아짐, 해가 존재하지 않거나 무한 그래프라면 결과가 안나옴

### JS코드
```
const graph = {
  1 : [2, 3],
  2 : [1, 3, 4, 5],
  3 : [1, 2, 6, 7],
  4 : [2, 5],
  5 : [2, 6],
  6 : [3, 7],
  7 : [3, 6]
}

const bfs = (graph, startNode) => {
  let checked = []; // 탐색된 노드들
  let unchecked = []; // 탐색해야될 노드들

  unchecked.push(startNode); //노드 탐색 시작

  while (unchecked.length !== 0) { //탐색할 노드가 남았다면
    const node = unchecked.shift(); 
    if (!checked.includes(node)) { // 해당 노드가 탐색된 적이 없다면
      checked.push(node);
      unchecked = [...unchecked, ...graph[node]];
    }
  }
  return checked
}
// result 1, 2, 3, 4, 5, 6, 7
```


# 깊이 우선 탐색 (DFS, Depth First Search)

* 최대한 깊이 내려가고 더이상 깊이 갈 곳이 없을 때까지 탐색 후 옆으로 이동
* 한 개의 큐와 스택을 이용
* DFS자체로의 의미모단, DFS를 이용한 그래프 알고리즘을 구현하여 활용적인 목적에 의미가 있다
* 작동 방식
  * 스택에 시작 노드를 넣는다
  * 스택이 비었으면 실행을 멈추고 false 반환
  * 스택의 맨 위 노드가 찾고자 하는 노드라면 탐색 종료 후 true 반환
  * 앞 단계에서 스택의 맨위 노드가 찾고자 하는 노드가 아니면 해당 노드를 pop하고, 스택에 들어온 적이 없는 pop한 노드의 모든 이웃 노드를 찾아 스택에 넣는다.
  * step3로 돌아감 반복
* 장점 - 현 경로상 노드를 기억하기 때문에 적은 메모리 사용, 찾으려는 노드가 깊은 단계에 있는 경우엔 BFS보다 빠르게 찾음
* 단점 - 해가 없는 경로를 탐색할 경우 끝날 때까지 탐색, DFS로 얻은 결과가 최단 경로라는 보장 없음, 비효율성


### JS코드
```
const graph = {
  1 : [2, 3],
  2 : [1, 3, 4, 5],
  3 : [1, 2, 6, 7],
  4 : [2, 5],
  5 : [2, 6],
  6 : [3, 7],
  7 : [3, 6]
}

const dfs = (graph, startNode) => {
  const checked = [];
  let unchecked = []
  
  unchecked.push(startNode);
  while (unchecked.length !== 0) {
    const node = unchecked.shift();
    if (!checked.includes(node)) {
      checked.push(node);
      unchecked = [...graph[node], ...unchecked]; // 스택구조로 먼저 쌓임 
    }
  }

  return checked;
}

// [1, 2, 3, 6, 7, 4, 5]
```
// dfs, bfs는 Convenant 블로그 참조


# Union-Find (합집합 찾기)

* 대표적인 그래프 알고리즘으로, 여러 개의 노드가 존재할 때 두 개의 노드를 선택해서, 현재 이 두 노드가 서로 같은 그래프에 속하는지 판별하는 알고리즘
* 서로 다른 두 노드가 연결되어 있을 땐 더 작은 값쪽으로 합칩니다.
* Union-Find 알고리즘은 다른 고급 그래프 알고리즘의 베이스가 됨

### JS코드
```
const parent = [];
for (let i = 0; i <= 10 i++) {
  parent[i] = i;
}

function getParent(arr, index) {
  if (arr[index] = index) return index;
  return arr[index] = getParent(arr, arr[index])
}

function unionParent(arr, a, b) {
  a = getParent(arr, a);
  b = getParent(arr, b);
  if (a < b) {
    arr[b] = a;
  } else {
    arr[a] = b;
  }
}

function findParent(arr, a, b) {
  a = getParent(arr, a);
  b = getParent(arr, b);

  if (a === b) {
    return true;
  } else {
    return false;
  }
}

unionParent(parent, 1, 2);
unionParent(parent, 2, 3);
unionParent(parent, 3, 4)
unionParent(parent, 5, 6)
unionParent(parent, 6, 7)
unionParent(parent, 7, 8)
console.log(findParent(parent, 1, 5)) // false;
unionParent(parent, 1, 5)
console.log(findParent(parent, 1, 5)) // true;
```

# Kruskal Algorithm (크루스칼 알고리즘)

* 가장 적은 비용으로 모든 노드를 연결하는 알고리즘, Union-Find를 이용, 최소 신장 트리(Minimal Spanning Tree)구하는 알고리즘
* 노드 - 정점, 간선 = 거리, 비용, 즉 두 노드 사이 관계 선
* 두 노드 사이 간선 거리(비용)가 짧은 순서대로 그래프에 포함시키기
* 간선 정보를 오름차순으로 정렬한 후, 비용이 적은 간선부터 차례 대로 그래프에 포함, 이때 사이클(순환 고리)이 형성되지 않도록


### JS코드
```
const parent = [];
for (let i = 0; i <= 7; i++) {
  parent[i] = i;
}

function getParent(arr, index) {
  if (arr[index] = index) return index;
  return arr[index] = getParent(arr, arr[index])
}

function unionParent(arr, a, b) {
  a = getParent(arr, a);
  b = getParent(arr, b);
  if (a < b) {
    arr[b] = a;
  } else {
    arr[a] = b;
  }
}

function findParent(arr, a, b) {
  a = getParent(arr, a);
  b = getParent(arr, b);

  if (a === b) {
    return true;
  } else {
    return false;
  }
}

// 동일하게 Union-Find를 이용
const costList = [[1, 7, 12], [1, 4, 28], [1, 2, 67], [1, 5, 17], [2, 4, 24], [2, 5, 62], [3, 5, 20], [3, 6, 37], [4, 7, 13], [5, 6, 45], [5, 7, 73]];

costList.sort((a, b) => a[2] > b[2]); // 오름차순으로 정리

let answer = 0;

for (let cost of costList) {
  if (!findParent(parent, cost[0], cost[1])) { //서로 연결 안되어있으면
    answer += cost[2];
    unionParent(parent, cost[0], cost[1]) // 서로 연결
  }
}
```