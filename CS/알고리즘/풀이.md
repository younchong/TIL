# leetcode 11. Container with Most water

- 문제
  height 배열이 주어지고 배열 내의 숫자로 물을 담을 수 있는 최대 넓이 구하기
- 내 풀이
  * 첫 풀이, 그리디 문제라서 하나씩 전체 체크하는 방식으로 구했음, 왼쪽에서 하나씩 움직이는 방향
  ```
  var maxArea = function(height) {
    let max = 0;
    for (let i = 0; i < height.length; i++) {
        let left = height[i];
        let rightIndex = i + 1;
        
        while (rightIndex < height.length){
            let vertical = Math.min(left, height[rightIndex]);   
            let bottom = rightIndex - i;
            let area = vertical * bottom;
            max = Math.max(max, area);
            rightIndex++;
        }
    }
    return max
  };
  ```
  * 결과 시간 초과

  * 두번째 풀이는 discussion에서 힌트를 얻어, 양쪽에서 좁혀오는 방향으로 계산
  ```
  var maxArea = function(height) {
    let left = 0;
    let right = height.length - 1;
    let max = 0;
    while (left < right) {
        let vertical = Math.min(height[left], height[right]);
        max = Math.max(max, (right - left) * vertical);
        if (height[left] < height[right]) {
            left++;
        } else {
            right--;
        }
    }
    
    return max;
  };
  ```
  * 통과

# BOJ 신입 사원

- 두 점수 중 적어도 하나는 다른 지원자들보다 등수가 높으면 뽑힘, 그때 뽑는 사람 수
- 처음엔 개개인별로 두 점수 비교하는 함수 만들어서 제출했는데 시간 초과
- 한 점수로 정렬한 후 다른 점수만 가지고 비교로 계산... (입력과정에서 시간초과인듯...)

```
const input = require("fs").readFileSync("/dev/stdin").toString().split("\n");
const T = input.shift() * 1;

for (let i = 0; i < T; i++) {
    const N = input.shift() * 1;
    let employee = [];
    let count = 1;
    for (let j = 0; j < N; j++) {
    employee.push(input.shift().split(" ").map(value => parseInt(value)));
    }
    employee.sort((a, b) => a[0] - b[0]);
    let temp = employee[0][1];
    for (let k = 0; k < employee.length; k++) {
      if (temp > employee[k][1]) {
          temp = employee[k][1];
          count++;
      }
    }
    console.log(count);
}
```

# leetcode 455 Assign Cookies

- 문제 : 아이가 먹을 수 있는 쿠키 크기와 쿠키 크기가 주어질때 쿠키 크기가 아이 수용량 보다 크거나 같으면 count
```
var findContentChildren = function(g, s) {
    let count = 0;
    s = s.sort((a, b) => a - b);
    for (let i = 0; i < g.length; i++) {
        let j = 0;
        while (j < s.length) {
            if (s[j] >= g[i]) {
                count++;
                s.splice(j, 1);
                break;
            }
            j++;
        }
    }
    
    return count;
};
```

# BOJ 2667 단지 번호 붙이기
* BFS 연습하려고 선택
- 문제 : 그래프 내에서 이어져있는 도형의 크기와 갯수, 구하기
```
const input = [
    7
0110100
0110101
1110101
0000111
0100000
0111110
0111000
]
const N = input.shift() * 1;
const graph = [];
for (let i = 0; i < N; i++) {
  graph.push(input.shift().split("").map(value => parseInt(value)));
}
const visited = Array.from(new Array(N), () => new Array(N).fill(0));
const countNumbers = [];

const bfs = (y, x) => {
    const mx = [1, -1, 0, 0];
    const my = [0, 0, 1, -1];
    const queue = [];
    visited[y][x] = 1;
    queue.push([y, x]);
    let count = 1;

    while (queue.length) {
        const [qy, qx] = queue.shift();
        for (let i = 0; i < 4; i++) {
            const ny = qy + my[i];
            const nx = qx + mx[i];
            if (ny >= 0 && ny < N && nx >= 0 && nx < N) {
                if (graph[ny][nx] === 1 && !visited[ny][nx]) {
                    visited[ny][nx] = 1;
                    queue.push([ny, nx]);
                    count++;
                }
            }
        }
    }
    countNumbers.push(count);
} 

for (let y = 0; y < N; y++;) {
    for (let x = 0; x < N; x++;) {
        if (graph[y][x] === 1 && visited[y][x]) {
            bfs(y, x);
        }
    }
}

console.log(countNumbers);
```