# 선택 정렬 (Selection Sort)

* 가장 직관적이고 구현하기 쉬움 (가장 작은것을 제일 앞으로 보낸다)
* 시간 복잡도 O(N^2)
* 다른 알고리즘 비교 비효율적이고 느린 알고리즘

### JS코드
```
const unsorted = [2, 7, 1, 3, 6, 8, 10, 5, 9, 4];

for (let i = 0; i < 10; i++) {
  let temp;
  let index;
  let min = 999;
  for (let j = i; j < 10; j++) {
    if (min > unsorted[j]) {
      min = unsorted[j];
      index = j
    }
  }

  temp = unsorted[i]; // 최솟값과 교환될 값
  unsorted[i] = unsorted[index]; // 최솟값이 맨 앞으로 이동
  unsorted[index] = temp; // 원래 최솟값있던 자리랑 교환
}
```

# 버블 정렬 (Bubble Sort)

* 옆에 있는 값과 비교해서 자리 바꾸기
* 간단하고 직관적
* 가장 효율이 떨어지고 느림 (매번 교체를 해서)
* 시간 복잡도 O(N^2)  (같은 시간복잡도라도 위와 같은 이유로 실제로는 더 느림)

### JS코드
```
const unsorted = [2, 3, 10, 8, 1, 5, 7, 4, 6, 9];

for (let i = 0; i < 10; i++) {
  for (let j = 0; j < 9 - i; j++) {
    if (unsorted[j] > unsorted[j + 1]) {
      let temp = unsorted[j];
      unsorted[j] = unsorted[j + 1];
      unsorted[j + 1] = temp;
    }
  }
}
```

# 삽입 정렬 (Insertion Sort)

* 삽입 정렬은 숫자를 적절한 위치에 삽입하는 알고리즘으로, 필요할 때만 위치를 변경
* 앞의 두 정렬과 비교해선 제일 빠르고, 효율적 (연산이 적음)
* 정렬이 되어있다고 가정 한다는 점에서 특정한 경우에 굉장히 빠름
* 거의 정렬된 상태라면 삽입정렬이 가장 효율적이고 빠름
* 시간 복잡도 O(N^2) (그래도 위의 이유로 앞 선 두 정렬보단 빠름)

### JS코드
```
const unsorted = [10, 2, 1, 8, 6, 3, 9, 4, 7, 5];

for (let i = 0; i < 9; i++) {
  while (i >= 0 && unsorted[i] > unsorted[i + 1]) {
    let temp = unsorted[i];
    unsorted[i] = unsorted[i + 1];
    unsoted[i + 1] = temp;
    i--;
  }
}
```

# 퀵 정렬 (Quick sort)

* 퀵 정렬은 대표적인 분할 정복 알고리즘으로 특정 값을 기준으로 큰 숫자와 작은 숫자로 나누는 개념이다.(잘게 나눈 후 정렬 후 합치기)
* 특정값, 기준값은 피벗이라고 함
* 시간 복잡도 O(N * logN), 굉장히 연산 속도 빠르고 효율적
* 이미 거의 정렬되어 있는 상태면 최악의 시간 복잡도 O(N*2)이 됨
* 정렬할 데이터 특성에 맞게 적절한 알고리즘을 사용하는 것이 바람직함, 일반적으론 퀵정렬이 빠르지만 거의 정렬되어 있는 data라면 삽입정렬이 더 빠름 
### JS코드
```
const unsorted = [10, 2, 5, 8, 6, 1, 4, 7, 3, 9];

function quickSort (data, start, end) {
  if (start >= end) {
    return;
  }

  let i = start + 1;
  let j = end;
  let key = start;
  let temp;

  while (i <= j) { //엇갈릴때 까지 반복
    while (i <= end && data[i] <= data[key]) { // 키 값보다 큰 값 찾기 -> 처음부터(키 바로 옆에서 부터)
      i++;
    }
    while (j > start && data[j] >= data[key]) { // 키값보다 작은 값 찾기 <- 끝에서부터
      j--;
    }

    if (i > j) { // 엇갈리면(key값보다 작거나 큰값이 없을 때) 키 값과 작은값 교체
      temp = data[j];
      data[j] = data[key];
      data[key] = temp;
    } else { // 엇갈리지 않으면, key값보다 작거나 큰값을 있을 경우
      temp = data[j];
      data[j] = data[i];
      data[i] = temp;
    }
  }

  quickSort(data, start, j - 1);
  quickSort(data, j + 1, end);
}
```


# 병합 정렬 (Merge Sort)

* 퀵정렬은 피벗값에 따라 편향된 분할결과를 만들 수도 있지만, 병합정렬은 최악의 경우에도 O(N * logN) 보장
* 일단 반으로 나누고 나중에 합치는 개념 (합치면서 정렬)
* 너비가 N, 높이가 logN
* 기존의 데이터를 담을 추가적인 배열 공간이 필요해서 메모리 활용이 비효율적임


### JS코드 구현
```
const unsorted = [3, 7, 2, 1, 5, 4, 5, 8];
const sorted = [];

mergeSort(unsorted, 0, unsorted.length - 1);

function merge (arr, start, middle, end) {
  let i = start;
  let j = middle + 1;
  let k = start;

  while (i <= middle && j <= end) { //i는 왼쪽에서부터, j는 중간부터 서로 크기 비교 후 sorted에 정렬
    if (arr[i] <= arr[j]) {
      sorted[k] = arr[i];
      i++;
    } else {
      sorted[k] = arr[j];
    }
    k++;
  }

  if (i > middle) { // 나머지 남은 배열 정렬
      for (let t = j; t <= end; t++) {
        sorted[k] = arr[t];
        k++;
      }
    } else {
      for (let t = i; t <= middle; t++) {
        sorted[k] = arr[t];
        k++;
      }
    }

    for (let t = start; t <= end; t++) { // 원래 arr에 sorted복사
      arr[t] = sorted[t];
    }
}

function mergeSort(arr, start, end) { // 재귀로 나타내기
  if (start < end) {
    let middle = parseInt((start + end) / 2);
    mergeSort(arr, start, middle);
    mergeSort(arr, middle + 1, end);
    merge(arr, start, middle, end);
  }
}

```

# 힙 정렬 (Heap sort)

* 힙 트리 구조를 이용하는 정렬 방식으로 이진트리와 힙에 대한 이해 필요
* 이진 트리는 모든 노드의 자식노드가 2개 이하인 노드이고, 완전 이진트리는 이진 트리의 노드가 중간에 비어있지 않고 빽빽한 구조
* 힙 트리는 완전 이진 트리를 기반으로 하는 트리로, 최댓값과 최솟값을 빠르게 찾기 위한 용도로 사용
* 트리는 가지를 뻗어가는 것 처럼 데이터가 서로 연결된 것
* 최대 힙은 부모노드가 자식노드보다 큰 힙
* 힙생성 알고리즘은 특정한 노드의 두 자식 중 더 큰 자식과 자신의 위치를 바꾸는 알고리즘, 이 특정노드를 제외하고는 최대 힙이 구성된 상태를 가정
* 별도의 메모리 사용이 없어서 효율적, 항상 O(N * logN) 보장

### JS코드
```
const N = 9;
const heap = [7, 6, 5, 8, 3, 5, 9, 1, 6];

for (let i = 1; i < N; i++) {
  let c = i;
  do {
    let root = (c - 1) / 2;
    if (heap[root] < heap[c]) {
      let temp = heap[root];
      heap[root] = heap[c];
      heap[c] = temp;
    }
    c = root;
  } while (c !== 0);
}

for (let i = N - 1; i >= 0; i--) {
  let temp = heap[0];
  heap[0] = heap[i];
  heap[i] = temp;
  
  let root = 0;
  let c = 1;
  do {
    c = 2 * root + 1;
    if (c < i - 1 && heap[c] < heap[c + 1]) {
      c++;
    }

    if (c < i && heap[root] < heap[c]) {
      let temp = heap[root];
      heap[root] = heap[c];
      heap[c] = temp;
    }
    root = c;
  } while (c < i);
}
```


# 계수 정렬 (Counting Sort)

* 범위 조건이 있는 경웨서 굉장히 빠른 알고리즘
* 크기를 기준으로 갯수를 세는 개념
* 데이터의 크기가 한정되어 있을 때만 사용 가능
* 시간 복잡도 O(N)

### JS코드
```
const N = 5;
const unsorted = [
  2, 3, 1, 4, 5, 2, 1, 2, 1, 4,
  5, 5, 3, 3, 2, 4, 3, 1, 2, 1,
  4, 4, 3, 2, 2, 1, 4, 3, 2, 5
]
const sorted = new Array(N).fill(0);

for (let i = 0; i < unsorted.length; i++) {
  sorted[unsorted[i] - 1]++;
}

let answer = "";

for (let i = 0; i < N; i++) {
  for (let j = 0; j < sorted[i]; j++) {
    answer += String(i + 1);
  }
}

```

# 스택 (Stack)과 큐 (Queue)

## 스택 (Stack)

* 가장 기본이 되는 자료 구조인 스택과 큐
* 자료 구조란 자료를 표현하고 처리하는 방법에 관한 것
* 알고리즘은 이런 자료 구조를 이용해서 문제를 해결하는 방법
* 스택은 가장 먼저 들어간 것이 가장 나중에 나가는 형태

### JS코드
```
const stack = [];

stack.push(4);
stack.push(5);
stack.push(2);
stack.pop();
stack.push(7);
stack.pop();
stack.pop();
stack.push(1);

console.log(stack) // 4, 1

```

## 큐 (Queue)

* 가장 먼저 들어온 것이 가장 먼저 나가는 구조
* 양 옆이 뚫린 터널 구조

### JS코드
```
const queue = [];

queue.push(2);
queue.push(7);
queue.push(4);
queue.shift();
queue.push(8);
queue.shift();
queue.push(1);

console.log(queue) // 4, 8, 1
```


# 너비 우선 탐색 (BFS, Breadth First Search)

* 탐색을 할 때 너비를 우선으로 하여 탐색을 수행하는 탐색 알고리즘
* 시작점을 기준으로 가까운 곳부터 탐색
* 맹목적인 탐색을 하고자 할때 사용할 수 있는 탐색 기법
* 최단경로를 찾아줌, 최단 길이를 보장할 때 많이 사용 (웹 크롤링, 가비지 컬렉션 등) 
* 큐를 필요로 함
* 작동 방식
  * 큐에서 하나의 노드를 꺼냄
  * 해당 노드에 연결된 노드 중 방문하지 않은 노드를 방문하고, 차례대로 큐에 삽입
  * 위 과정 반복
* 너비 우선 탐색 알고리즘 자체보단 다른 알고리즘에 적용되어 효과적으로 사용되는 것에 의미가 있다
* 장점  - 답이 되는 경로가 여러 개인 경우 최단경로임을 보장, 최단경로가 존재하면 깊이가 깊어져도 찾을 수 있음
* 단점 - 경로가 길 경우 메모리 사용 많아짐, 해가 존재하지 않거나 무한 그래프라면 결과가 안나옴

### JS코드
```
const graph = {
  1 : [2, 3],
  2 : [1, 3, 4, 5],
  3 : [1, 2, 6, 7],
  4 : [2, 5],
  5 : [2, 6],
  6 : [3, 7],
  7 : [3, 6]
}

const bfs = (graph, startNode) => {
  let checked = []; // 탐색된 노드들
  let unchecked = []; // 탐색해야될 노드들

  unchecked.push(startNode); //노드 탐색 시작

  while (unchecked.length !== 0) { //탐색할 노드가 남았다면
    const node = unchecked.shift(); 
    if (!checked.includes(node)) { // 해당 노드가 탐색된 적이 없다면
      checked.push(node);
      unchecked = [...unchecked, ...graph[node]];
    }
  }
  return checked
}
// result 1, 2, 3, 4, 5, 6, 7
```


# 깊이 우선 탐색 (DFS, Depth First Search)

* 최대한 깊이 내려가고 더이상 깊이 갈 곳이 없을 때까지 탐색 후 옆으로 이동
* 한 개의 큐와 스택을 이용
* DFS자체로의 의미모단, DFS를 이용한 그래프 알고리즘을 구현하여 활용적인 목적에 의미가 있다
* 작동 방식
  * 스택에 시작 노드를 넣는다
  * 스택이 비었으면 실행을 멈추고 false 반환
  * 스택의 맨 위 노드가 찾고자 하는 노드라면 탐색 종료 후 true 반환
  * 앞 단계에서 스택의 맨위 노드가 찾고자 하는 노드가 아니면 해당 노드를 pop하고, 스택에 들어온 적이 없는 pop한 노드의 모든 이웃 노드를 찾아 스택에 넣는다.
  * step3로 돌아감 반복
* 장점 - 현 경로상 노드를 기억하기 때문에 적은 메모리 사용, 찾으려는 노드가 깊은 단계에 있는 경우엔 BFS보다 빠르게 찾음
* 단점 - 해가 없는 경로를 탐색할 경우 끝날 때까지 탐색, DFS로 얻은 결과가 최단 경로라는 보장 없음, 비효율성


### JS코드
```
const graph = {
  1 : [2, 3],
  2 : [1, 3, 4, 5],
  3 : [1, 2, 6, 7],
  4 : [2, 5],
  5 : [2, 6],
  6 : [3, 7],
  7 : [3, 6]
}

const dfs = (graph, startNode) => {
  const checked = [];
  let unchecked = []
  
  unchecked.push(startNode);
  while (unchecked.length !== 0) {
    const node = unchecked.shift();
    if (!checked.includes(node)) {
      checked.push(node);
      unchecked = [...graph[node], ...unchecked]; // 스택구조로 먼저 쌓임 
    }
  }

  return checked;
}

// [1, 2, 3, 6, 7, 4, 5]
```
// dfs, bfs는 Convenant 블로그 참조


# Union-Find (합집합 찾기)

* 대표적인 그래프 알고리즘으로, 여러 개의 노드가 존재할 때 두 개의 노드를 선택해서, 현재 이 두 노드가 서로 같은 그래프에 속하는지 판별하는 알고리즘
* 서로 다른 두 노드가 연결되어 있을 땐 더 작은 값쪽으로 합칩니다.
* Union-Find 알고리즘은 다른 고급 그래프 알고리즘의 베이스가 됨

### JS코드
```
const parent = [];
for (let i = 0; i <= 10 i++) {
  parent[i] = i;
}

function getParent(arr, index) {
  if (arr[index] = index) return index;
  return arr[index] = getParent(arr, arr[index])
}

function unionParent(arr, a, b) {
  a = getParent(arr, a);
  b = getParent(arr, b);
  if (a < b) {
    arr[b] = a;
  } else {
    arr[a] = b;
  }
}

function findParent(arr, a, b) {
  a = getParent(arr, a);
  b = getParent(arr, b);

  if (a === b) {
    return true;
  } else {
    return false;
  }
}

unionParent(parent, 1, 2);
unionParent(parent, 2, 3);
unionParent(parent, 3, 4)
unionParent(parent, 5, 6)
unionParent(parent, 6, 7)
unionParent(parent, 7, 8)
console.log(findParent(parent, 1, 5)) // false;
unionParent(parent, 1, 5)
console.log(findParent(parent, 1, 5)) // true;
```

# Kruskal Algorithm (크루스칼 알고리즘)

* 가장 적은 비용으로 모든 노드를 연결하는 알고리즘, Union-Find를 이용, 최소 신장 트리(Minimal Spanning Tree)구하는 알고리즘
* 노드 - 정점, 간선 = 거리, 비용, 즉 두 노드 사이 관계 선
* 두 노드 사이 간선 거리(비용)가 짧은 순서대로 그래프에 포함시키기
* 간선 정보를 오름차순으로 정렬한 후, 비용이 적은 간선부터 차례 대로 그래프에 포함, 이때 사이클(순환 고리)이 형성되지 않도록


### JS코드
```
const parent = [];
for (let i = 0; i <= 7; i++) {
  parent[i] = i;
}

function getParent(arr, index) {
  if (arr[index] === index) return index;
  return arr[index] = getParent(arr, arr[index])
}

function unionParent(arr, a, b) {
  a = getParent(arr, a);
  b = getParent(arr, b);
  if (a < b) {
    arr[b] = a;
  } else {
    arr[a] = b;
  }
}

function findParent(arr, a, b) {
  a = getParent(arr, a);
  b = getParent(arr, b);

  if (a === b) {
    return true;
  } else {
    return false;
  }
}

// 동일하게 Union-Find를 이용
const costList = [[1, 7, 12], [1, 4, 28], [1, 2, 67], [1, 5, 17], [2, 4, 24], [2, 5, 62], [3, 5, 20], [3, 6, 37], [4, 7, 13], [5, 6, 45], [5, 7, 73]];

costList.sort((a, b) => a[2] > b[2]); // 오름차순으로 정리

let answer = 0;

for (let cost of costList) {
  if (!findParent(parent, cost[0], cost[1])) { //서로 연결 안되어있으면
    answer += cost[2];
    unionParent(parent, cost[0], cost[1]) // 서로 연결
  }
}
```

# 이진 트리의 구현과 순회방식

* 비선형 자료구조에서 가장 많이 사용되는 이진 트리, 데이터의 탐색 속도 증진을 위해 주로 사용, 포인터와 트리로 구성
* 포인터를 이용해서 완전 이진 트리가 아니더라도 안정적으로 노드들을 가르킬 수 있음
* 데이터 탐색 방식
  * 전위 순회 (Preorder Traversal) - 자신 -> 왼쪽 -> 오른쪽
  * 중위 순회 (Inorder Traversal) - 왼쪽 -> 자신 -> 오른쪽
  * 후위 순회 (Postorder Traversal) - 왼쪽 -> 오른쪽 -> 자신

### JS코드
```
class BinarySearchTree {
  constructor(value) {
    this.value = value;
    this.left = null;
    this.right = null;
  }

  insert(value) {
    if (value < this.value) { //새로 들어온 value가 이 트리에 원래있던 this.value보다 작으면 왼쪽으로 먼저 들어감
      if (this.left === null) { // 왼쪽 비었으면
        this.left = new BinarySearchTree(vale);
      } else {
        this.left.insert(value); //안 비었을 때는 왼쪽의 자식노드로 insert함수 재귀
      }
    } else if (value > this.value) { // 새로들어온 value가 더 크면 오른쪽으로
        if (this.right === null) {
          this.right = new BinarySearchTree(value);
        } else {
          this.right.insert(value);
        }
    } else {
      // 이미 포함되어있는 경우
    }
  }

  contain(value) {
    if (value === this.value) {
      return true;
    }

    if (value < this.value) {
      return !!(this.left && this.left.contain(value)) // 작으면 왼쪽 확인, left있나 확인 후 contain함수로 확인
    }

    if (value > this.value) {
      return !!(this.right && this.right.contain(value));
    }
  }

  preorder(callback) { // 자신 -> 왼 -> 오
    callback(this.value);
    if (this.left) {
      this.left.preorder(callback);
    }
    if (this.right) {
      this.right.preorder(callback)
    }
  }

  inorder(callback) { // 왼 -> 자신 -> 오
    if (this.left) {
      this.left.inorder(callback);
    }
    callback(this.value);
    if (this.right) {
      this.right.inorder(callback);
    }
  }

  postorder(callback) { // 왼 -> 오 -> 자신
    if (this.left) {
      this.left.postorder(callback);
    }
    if (this.right) {
      this.right.postorder(callback);
    }
    callback(this.value);
  }
}
```

# 다이나믹 프로그래밍 (Dynamic Programming)

* 하나의 문제는 단 한 번만 풀도록 하는 알고리즘
* 두 가지 가정
  * 큰 문제를 작은 문제로 나눌 수 있음
  * 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일
* 크고 어려운 문제를 잘게 나누어 해결한 뒤 처리한 후 나중에 전체의 답을 구하는 것
* 시간 복잡도는 O(N) 


### JS코드
```
const dp = [0]; // 피보나치 예시

let fibonacci = (n) => { // 처음에 함수 선언식으로 했다가 에러발생 변경 jakeseo velog 참조
  if (n < 3) {
    dp[n] = 1;
  }
  if (!dp[n]) { //값이 없다면 피보나치 재귀함수로 값 저장
    dp[n] = fibonacci(n - 1) + fibonacci(n - 2);
  }

  return dp[n];
}

```

# 에라토스테네스의 체

* 대표적인 소수 판별 알고리즘 중 소수를 대량으로 빠르고 정확하게 구하는 방법
* 구현 단계
  * 소수를 판별할 범위만큼 배열을 할당하고 인덱스에 해당 값을 넣는다.
  * 2부터 시작해서 특정 숫자의 배수에 해당하는 수들은 지운다.
  * 남아있는 수들을 출력


### JS코드
```
function primeNumberSieve(n) {
  const primes = new Array(n);
  
  for (let i = 0; i <= n; i++) {
    primes[i] = i;
  }

  for (let i = 2; i * i <= n; i++) {
    if (primes[i] !== 0) {
      let k = 2;
      while (i * k <= n) { // 배수들 제거하기
        primes[i * k] = 0;
        k++;
      }
    }
  }

  return primes;
}

```

# 다익스트라 알고리즘 (Dijkstar Algorithm)

* 다이나믹 프로그래밍을 활용한 대표적인 최단 경로탐색 알고리즘
* 특정한 하나의 정점에서 다른 모든 정점으로 가는 최단 경로 알려줌
* 다이나믹 프로그래밍을 활용한 방식은 최단 거리가 여러 개의 최단 거리로 이루어져 있는 것을 이용, 하나의 최단 거리를 구할 때 그 이전까지 구했던 최단 거리 정보를 그대로 사용
* 구현과정
  * 출발 노드 설정
  * 출발 노드 기준 각 노드의 최소 비용 저장
  * 방문하지 않은 노드(출발 노드 제외 나머지 노드) 중에서 가장 비용이 적은 노드를 선택
  * 해당 노드를 거쳐 특정한 노드로 가는 경우를 고려하여 최소 비용 갱신
  * 3 ~ 4번 과정 반복
* 단점 - 시간복잡도 O(N^2), N은 꼭짓점의 갯수

### JS구현
```
const INF = Infinity;
const arr = [
  [0, 2, 5, 1, INF, INF],
  [2, 0, 3, 2, INF, INF],
  [5, 3, 0, 3, 1, 5],
  [1, 2, 3, 0, 1, INF],
  [INF, INF, 1, 1, 0, 2],
  [INF, INF, 5, INF, 2, 0]
]
const visited = new Array(6).fill(false);

const getSmallIndex = function(vertex) {
  let min = INF;
  let idx = 0;
  for (let i = 0; i< vertex.length; i++) {
    if (min > vertex[i] && !visited[i]) {
      min = vertex[i];
      idx = i;
    }
  }
  
  return idx;
}

const dist = function(start) {
  let v = arr[start - 1];
  let count = 0;
  let end = v.length;
  let min = 0;
  let startV = v;
  visited[start - 1] = true;
  
  while (count < end) {
    const idx = getSmallIndex(startV);
    min += startV[idx];
    const next = arr[idx];
    for (let i = 0; i< v.length; i++) {
      if (v[i] > next[i] + min && !visited[i]) {
        v[i] = next[i] + min;
      }
    }
    
      startV = arr[idx];
      visited[idx] = true;
      count++;
  }
  console.log(v);
}

dist(1);
// 천유린 개발블로그 참조
```

* 최소 힙에 기반한 다익스트라 알고리즘
* 인접 리스트를 이용
// 이해 못함, 좀 더 공부 후 적기
### JS구현
```
```

# 플로이드 와샬 알고리즘 (Floyd Warshall Algorithm)

* 모든 정점에서 모든 정점으로의 최단 경로 
* 다이나믹 프로그래밍 기술에 의거함
* 알고리즘의 핵심 아이디어는 거쳐가는 정점을 기준으로 최단거리를 구하기 (x에서 y로 가는 비용 vs  x에서 z노드 가는 비용 + z노드에서 y가는 비용)
* 시간 복잡도 O(N^3)으로 비효율적이나 모든 경로 최단 거리 구할 수 있음

### JS코드
```
const graph = [
  [0, 5, INF, 8],
  [7, 0, 9, INF],
  [2, INF, 0, 4],
  [INF, INF, 3, 0]
]

const floydWarshall = (dist) => {
  const N = dist.length;


  //i는 거쳐가는 노드
  for (let i = 0; i < N; i++) {
    // j는 출발 노드
    for (let j = 0; j < N; j++) {
      // k는 도착 노드
      for (let k = 0; k < N; k++) {
        if (dist[j][i] + dist[i][k] < dist[j][k]) {
          dist[j][k] = dist[j][i] + dist[i][k];
        }
      }
    }
  }

  return dist;
}

floydWarshall(graph);
// result [[0, 5, 11, 8], [7, 0, 9, 13], [2, 7, 0, 4], [5, 10, 3, 0]] 
```

# 위상 정렬 (Topology Sort)

* 순서가 정해져있는 작업을 차례대로 수행해야 할 때  순서를 결정해주기 위해 사용하는 알고리즘
* 사이클이 발생하지 않는 방향 그래프에서만 적용 가능
* 두 가지 해결책 도출
  * 현재 그래프가 위상 정렬이 가능한지
  * 가능하면 결과가 무엇인지
* 스택을 이용하는 방식과 큐를 이용한 방식이 있다.
* 구현 과정 (큐 사용)
  * 진입차수가 0인 정점을 큐에 삽입
  * 큐에서 원소를 꺼내 연결된 모든 간선을 제거
  * 간선 제거 이후에 진입차수가 0이 된 정점을 큐에 삽입
  * 큐가 빌때 까지 2~3 과정 반복
  * 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재하는 것이고, 모든 원소를 방문했다면 큐에서 꺼낸 순서가 위상 정렬의 결과이다.
* 시간 복잡도 O(V + E) V는 노드 개수, E는 간선의 개수

### JS구현
```
const N = 7;
const graph = [0, [2, 5], [3], [6], [6], [7], []];
const inDegree = new Array(N + 1).fill(0);
for (let i = 1; i < graph.length; i++) {
  const node = graph[i];
  for (let j = 1; j < node.length; j++) {
    inDegree[node[j]]++;
  }
}

const queue = [];
for (let i = 1; i <= N; i++) {
  if (!inDegree[i]) {
    queue.push(i);
  }
}

const result = [];
while (queue.length) {
  const n = queue.pop(); // 큐에서 제거
  result.push(n);
  graph[n].forEach(v => { 
    inDegree[v]--;  //다음 노드 degree 하나 줄이고
    if (!inDegree[v]) { // 다음 노드 degree가 0이라면 queue에 넣기
      queue.push(v);
    }
  });
}

console.log(result) // 1 5 2 3 4 6 7
```


# 강한 결합 요소 (Strongly Connected Component)

* 강한 결합 요쇼란 강하게 결합된 정점의 집합으로, 사이클을 이루는 정점들의 집합이다. 같은 SCC에 속하는 두 정점은 서로 도달이 가능하다. 
* 정점들 사이 경로가 항상 존재 하지만, 한 방향 경로만 존재 (a -> b ok, b -> a no)
* SCC를 추출하는 대표적인 알고리즘으로 코사라주 알고리즘(Kosaraju's Algorithm)과 타잔 알고리즘(Tarjan's Algorithm)
* 코사라주 알고리즘이 구현이 쉬움, 타잔 알고리즘은 적용이 쉬움
* 타잔 알고리즘은 dfs를 적용하여 방문한 노드들을 스택에 저장하면서 강한 결합 요소를 찾는 알고리즘이다.
* 강한 결합 요소 그 자체로는 의미가 없고, 위상 정렬과 함께 생각할 때 큰 의미가 있음
* 강한 결합 요소의 타잔 알고리즘의 시간 복잡도 O(V + E)

### JS구현
```
const graph = [
  0,
  [2],
  [3],
  [1],
  [2, 5],
  [7],
  [5],
  [6]
]
const isVisited = new Array(8).fill(false);
const isFinished = new Array(8).fill(false);
const stack = [];
const scc = [];

const dfs = (vertex) => {
  let parent = vertex;
  isVisited[vertex] = true;
  stack.push(vertex);
  
  for (let i =0; i < graph[vertex].length; i++) {
    const nextVertex = graph[vertex][i];
    if (!isVisited[nextVertex]) {
      parent = Math.min(parent, dfs(nextVertex)); // 여기서 재귀, 사이클 돌면서 시작, 가장 작은 노드 구함
    } else if (!isFinished[nextVertex]) {
      parent = nextVertex;
    }
  }

  if (parent === vertex) { // stack에 1, 2, 3 쌓이고 (처음 기준)
    const sccElement = [];
    let topElement = 0;
    do {
      topElement = stack.pop();
      isFinished[topElement] = true;
      sccElement.unshift(topelement); // srcElement에 3, 2, 1 쌓임
    } while (topElement !== parent);
    scc.push(sccEl); //scc 에 [3, 2, 1] push
  }

  return parent;
}

const tarjan = () => {
  let parent = 0;
  let topElement = 0;
  for (let vertex = 1; vertex < graph.length; vertex++) {
    if (!isFinished[vertex]) {
      dfs(vertex);
    }
  }
}

tarjan();
console.log(scc);
// 천유린 블로그 참조
```

# 네트워크 플로우 (Network Flow)

* 특정한 지점에서 다른 지점으로 데이터가 얼마나 흐르는지 측정하는 알고리즘 (교통 체증, 네트워크 데이터 전송 등에서 활용)
* 네트워크 플로우 알고리즘의 핵심 아이디어는 최대 유량 문제로 생각할 수 있음 
* 최대 유량문제란, 각 간선에 정해진 용량이 있을 때 최대로 보낼 수 있는 유량 크기
* BFS를 이용한 에드몬드 카프 알고리즘 사용
* 남아있는 모든 가능한 경로를 다 찾기 위해 음의 유량을 계산해줌, 유량이 지나가는 반대 방향의 유량
* 에드몬드 카프 알고리즘의 시간 복잡도는 O(VE^2)

### JS구현  
```
//아직 모르겠다. c++ -> js 구현은
```

# 이분 매칭 (Bipartite Matching)

* 네트워크 플로우 개념 중에서 이분 그래프에서의 최대 매칭을 구하는 경우를 이분 매칭이라 함
* 두 집단이 있을 때 최대로 많이 선택하는 경로가 생기도록 하는 알고리즘
* DFS 이용하여 알고리즘 구현
* 시간 복잡도는 O(V * E), 빠른 속도의 알고리즘은 아니지만 간단하고 쉬움

### JS구현
```
const N = 3;
const graph = [0, [1, 2, 3], [1], [2]];
const inDegree = [0, 0, 0, 0];
const visited = new Array(N + 1).fill(false);


const dfs = (n) => {
  for (let i = 0; i < graph[n].length; i++) {
    let node = graph[n][i];
    
    if (visited[node]) continue;
    visited[node] = true;
    if (inDegree[node] === 0 || dfs(inDegree[node])) {
      inDegree[node] = n;
      visited[node] = false;
      return true;
    }
  }
  
  return false;
}
let count = 0;

for (let i = 1; i <= N; i++) {
  if (dfs(i)) count++;
}

for (let i = 1; i < 4; i++) {
  if (inDegree[i] !== 0){
    console.log(`${inDegree[i]}는 ${i}랑 연결`) ///"2는 1랑 연결" "3는 2랑 연결" "1는 3랑 연결"
  }
}
```

# 그리디 알고리즘 (Greedy)

* 현재 상황에서 지금 당장 좋은 것만 고르는, 최적의 상황만을 쫓는 알고리즘, 가장 단순한 형태의 알고리즘
* 항상 최적의 결과를 도출하는 것은 아니지만, 어느 정도 최적의 해에 근사한 값을 빠르게 구할 수 있음, 특정한 상황에서는 최적의 해를 보장
* 그리디 알고리즘은 무조건 큰 경우대로, 무조건 작은 경우대로, 긴 경우대로, 짧은 경우대로... 와 같이 극단적인 방식으로 문제에 접근해서 정렬(Sort)기법과 함께 사용하는 경우가 많음

### JS구현
```
거스름돈 구현

function changeCal(money) {
  let real = money;
  let result = 0;
  result += Math.floor(money / 500);
  money %= 500;
  result += Math.floor(money / 100);
  money %= 100;
  result += Math.floor(money / 50);
  money %= 50
  result += Math.floor(money / 10);
  return result;
}

changeCal(1260) // 6개
```

# 단순 문자열 매칭 알고리즘

* 특정한 글 안에서 하나의 문자열을 찾는 알고리즘
* 하나씩 확인하는 알고리즘으로 가장 간단한 형태의 알고리즘, 직관적이지만  시간 복잡도 O(N * M)을 가짐

### JS구현

```
function findString(parent, pattern) {
  const parentSize = parent.length;
  const patternSize = pattern.length;
  
  for (let i = 0; i <= parentSize - patternSize; i++) {
    let isFound = true;
    for (let j = 0; j < patternSize; j++) {
      if(parent[i + j] !== pattern[j]) {
        isFound = false;
        break;
      }
    }
    if (isFound) {
      return i;
    }
  }
  
  return -1;
  
} 

const result = findString("Hello World", "llo W")
console.log(result) // 2
// indexOf가 있어서...
```

# KMP(Knuth-Morris-Pratt) 알고리즘

* 접두사와 접미사의 개념을 활용하여 반복되는 연산을 얼마나 줄일 수 있는 지를 판별하여 매칭할 문자열을 빠르게 점프하는 기법
* 접두사와 접미사를 이용해 매칭에 실패했을 때 현재 탐색중인 부분에서 접미사와 접두사가 일치하는 부분으로 점프해서 넘어가는 탐색
* 접두사와 접미사가 일치하는 최대 길이 만큼 점프를 할 수 있음
* 시간복잡도는 O(N + M)

### JS구현
```
function makeTable(word) {
  const table = [0];
  let prefix = 0;
  let suffix = 1;

  while (suffix < word.length) {
    if (word[prefix] === word[suffix]) {// 일치하는 경우는 접두사 접미사 둘다 증가,
      table[suffix] = prefix + 1; // 접미사 위치의 테이블값은 접두사 값 + 1
      prefix++;
      suffix++;
    } else if (prefix === 0) {
      table[suffix] = 0;
      suffix++;
    } else { // 일치하지 않는 경우는 접두사는 테이블 이전 접두사 값을 가짐.
      prefix = table[prefix - 1];
    }
  }

  return table;
}

function KMP(parent, pattern) {
  if (pattern.length === 0) return 0;

  let parentIndex = 0;
  let patternIndex = 0;

  const patternTable = makeTable(pattern);

  while (parentIndex < parent.length) {
    if (parent[parentIndex] === pattern[patternIndex]) { // 문자가 일치한다면
      if (patternIndex === pattern.length - 1) { // 전체가 일치할 경우
        return parentIndex - pattern.length + 1; // 인덱스 제공
      }
      parentIndex++;
      patternIndex++;
    } else if (patternIndex > 0) { // 일치하지 않을 경우 
      patternIndex = patternTable[patternIndex - 1]; // 이전 단계 값으로 바꿔줌
    } else {
      patternIndex = 0;
      parentIndex++;
    }
  }

  return -1;
}
// yujo velog 참조, 복습 필수
```

# 라빈 카프(Rabin-Karp) 알고리즘

* 항상 빠르지는 않지만 일반적인 경우 빠르게 작동하는 간단한 구조의 문자열 매칭 알고리즘
* 해시기법을 사용함, 해시는 긴 데이터를 그것을 상징하는 짧은 데이터로 바꾸어주는 기법을 말함
* 문자열의 해시 값을 비교하여 그 일치 여부를 검사하는 알고리즘
* 구현 자체가 간단함
* 안정적인 프로그램을 작성하고자 할때는 나머지 연산(맞는지 비교)
* 시간 복잡도 O(N)

### JS구현
```
function findString(parent, pattern) {
  const parentSize = parent.length;
  const patternSize = pattern.length;
  let parentHash = 0;
  let patternHash = 0;
  let power = 1;
  let isFound = false;

  for (let i = 0; i <= parentSize - patternSize; i++) {
    if (i === 0 ) {
      for (let j = 0; j < patternSize; j++) {
        parentHash = parentHash + parent.charCodeAt(patternSize - 1 - j) * power; // 뒤 쪽부터 계산
        patternHash = patternHash + pattern.charCodeAt(patternSize - 1 - j) * power;

        if (j < patternSize - 1) power = power * 2;
      }
    } else {
      parentHash = 2 * (parentHash - parent.charCodeAt(i - 1) * power) + parent.charCodeAt(patternSize - 1 + i);
    }

    if (parentHash === patternHash) {
      isFound = true;
      for (let j = 0; j < patternSize; j++) {
        if (parent.charCodeAt(i + j) !== pattern.charCodeAt(j)) {
          isFound = false;
          break;
        }
      }

      if (isFound) {
        console.log(`${i + 1}번째에서 발견`)
      }
    }
  }
}

findString("ababacabacaabacaaba", "abacaaba") // 7번째에서 발견 12번째에서 발견
```

# 그래프 탐색 알고리즘 DFS, BFS 복습

* 먼저 알고 있어야 되는 개념, 스택, 큐, 재귀함수
* 문제 풀이로 복습
* 시간 복잡도 O(V + E);
### BFS  구현
```
const N = 8;
const graph = [
  [],
  [2, 3, 8],
  [1, 7],
  [1, 4, 5],
  [3, 5],
  [3, 4],
  [7],
  [2, 6, 8],
  [1, 7]
]
const queue = [];
const visited = new Array(N + 1).fill(false);

const bfs = (graph, start, visited) => {
  queue.push(start);
  visited[start] = true;
  
  while (queue.length) {
    let vertex = queue.shift();
    for (let node of graph[vertex]) {
      if (visited[node]) continue;
      queue.push(node);
      visited[node] = true;
    }
  }
}
```
### DFS 구현
```
const N = 8;
const graph = [
  [],
  [2, 3, 8],
  [1, 7],
  [1, 4, 5],
  [3, 5],
  [3, 4],
  [7],
  [2, 6, 8],
  [1, 7]
]
const visited = new Array(N + 1).fill(false);

const dfs = (graph, v, visited) => {
  visited[v] = true;

  for (let node of graph[v]) {
    if (visited[node]) continue;
    dfs(graph, node, visited);
  }
}
```

# 정렬 알고리즘

## 선택 정렬
* 처리되지 않은 데이터 중에서 가장 작은 데이터를 선택해서 맨 앞에 있는 데이터와 바꾸는 것을 반복
* 시간 복잡도 O(N^2)
### JS코드 구현
```
const numbers = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8];

for (let i = 0; i < numbers.length; i++) {
  let minIndex = i;
  for (let j = i + 1; j < numbers.length; j++) {
    if (numbers[j] < numbers[minIndex]) {
      minIndex = j;
    }
  }
  let temp = numbers[i];
  numbers[i] = numbers[minIndex];
  numbers[minIndex] = temp;
}

console.log(numbers) // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
```

## 삽입 정렬
* 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입, 기준에 왼쪽인지(작은지), 오른쪽인지(큰지)
* 선택 정렬보다 구현난이도는 높지만, 일반적으로 더 효율적, 현재 리스트가 거의 정렬되어 있다면 매우 빠르게 동작(이때 시간복잡도 O(N))
* 시간복잡도 O(N^2), 반복문 2번 중첩되어 사용
### JS코드 구현
```
const numbers = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8];

for (let i = 1; i < numbers.length; i++) { // 두번재 원소부터 마지막 원소까지 탐색
  for (let j = i ; j >= 0; j--) {
    if (numbers[j] < numbers[j - 1]) { // 한칸씩 왼쪽으로 이동
      let temp = numbers[j];
      numbers[j] = numbers[j - 1];
      numbers[j - 1] = temp;
    } else { // 자신보다 작은 값을 만나면 그 위치에서 멈춤
      break;
    }
  }
  
}

console.log(numbers)
```

## 퀵 정렬
* 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법
* 일반적인 상황에서 가장 많이 사용되는 정렬 알고리즘 중 하나
* 가장 기본적인 퀵 정렬은 첫 번째 데이터를 기준 데이터(pivot)로 설정
* 구현 과정
  * 왼쪽에서부터는 피벗 값보다 큰 데이터를, 오른쪽에서부터는 피벗 값보다 작은 데이터를 고른다.
  * 선택된 두 값의 위치를 바꿔준다.
  * 두 과정을 반복하다가 위치가 엇갈릴 경우(왼쪽에서 오는 경우와 오른쪽에서 오는경우)에는 피벗값과 엇갈렸을 때의 작은값의 위치를 변경함
  * 이때 피벗값의 위치를 기준으로 왼쪽으로는 작은 값들이, 오른쪽으로는 큰 값들이 나눠지는데, 이렇게 데이터 묶음을 나누는 작업을 분할이라고 함
  * 이휘 왼쪽에 데이터들끼리 퀵정렬, 오른쪽에 있는 데이터들끼리 퀵정렬을 수행, 재귀적으로 수행하며 퀵정렬 범위가 좁아짐
* 평균 시간복잡도 O(NlogN)이지만, 최악의 경우엔(이미 정렬되어 있는 경우) O(N^2)

### JS구현
```
const numbers = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8];
function quickSort(arr, start, end) {
  if (start >= end) return;
  let pivot = start;
  let left = start + 1;
  let right = end;

  while (left <= right) {
    while (left <= end && arr[left] <= arr[pivot]) left++;
    while (right > start && arr[right] >= arr[pivot]) right--;

    if (left >= right) { // 엇갈리면
      let temp = arr[pivot];
      arr[pivot] = arr[right];
      arr[right] = temp;
    } else {
      let temp = arr[left];
      arr[left] = arr[right];
      arr[right] = temp;
    }
  }
  quickSort(arr, start, right - 1);
  quickSort(arr, right + 1, end);
}
```

## 계수 정렬
* 특정한 조건이 부합할 때만 사용할 수 있지만, 매우 빠르게 동작하는 정렬 알고리즘
* 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때 사용가능
* 데이터의 개수가 N, 데이터(양수) 중 최댓값이 K일 때 최악의 경우에도 수행 시간 O(N + K)를 보장
* 모든 데이터의 범위를 포함할 수 있는 크기의 배열을 만들어서 각각의 데이터가 몇번 등장했는지 (count sort), count한 값을 인덱스에 값으로 주어서 정렬
* 공간복잡도가 높지만 O(N + K), 조건만 만족한다면 퀵정렬보다 빠르게 동작함 (데이터의 갯수 N, 가장 큰 값 K)
* 계수 정렬은 동일한 값을 가지는 데이터가 여러 번 등장할 때 효과적으로 사용
### JS구현
```
const numbers = [7, 5, 9, 0, 3, 1, 6, 2, 9, 4, 8, 0, 5, 2];
const count = new Array(Math.max(...numbers) + 1).fill(0);
const sorted = [];

for (let i = 0; i < numbers.length; i++) {
  count[numbers[i]]++;
}

for (let i = 0; i < count.length; i++) {
  for (let j = 0; j < count[i]; j++) {
    sorted.push(i);
  }
}

console.log(sorted); // [0, 0, 1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 9]

```

# 이진 탐색 알고리즘
* 정렬되어 있는 리스트에서 탐색 범위를 절반씩 좁혀가며 데이터를 탐색하는 방법
* 이진 탐색은 시작점, 끝점, 중간점을 이용하여 탐색 범위를 설정함.
* 이진 탐색은 탐색 범위를 절반씩 줄이며 시간 복잡도는 O(logN) 보장
* 파라메트릭 서치 문제 (최적화 문제를 결정문제(yes or no)로 바꾸어 해결하는 기법)는 이진 탐색을 이용하여 해결가능
* 문제에서 큰 탐색 범위를 보면 가장 먼저 이진 탐색을 떠올려야 함
### JS구현
```
const binarySearch = (arr, target, start, end) => {
  if (start > end) return;
  let mid = parseInt((start + end) / 2);
  
  if (arr[mid] === target) {
    return mid;
  } else if (arr[mid] > target) {
    return binarySearch(arr, target, start, mid - 1);
  } else {
    return binarySearch(arr, target, mid + 1, end);
  }
  
}

const numbers = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19];

console.log(binarySearch(numbers, 7, 0, 9)); // 3

// 반복문 구현

while (start <= end) {
  let mid = parseInt((start + end) / 2);
 
  if (arr[mid] === target) {
    result = mid;
  } else if (arr[mid] < target) {
    start = mid + 1;
  } else {
    end = mid - 1;
  }
}

```
// 확실히 알고리즘 공부하고 다시 보니까 스스로 구현하는데도 어려움이 없고, 이해하는기도 더 쉽다.

# 다이나믹 프로그래밍

* 메모리를 적절히 사용하여 수행하여 수행 시간 효율성을 비약적으로 향상시키는 방법
* 이미 계산된 결과(이전 작은 문제들)는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 함, 한번 해결한 문제는 다시 해결안해도 됨
* 일반적으로 두가지 방식으로 구성
  * top-down (하향식)
    * Memoization - 하향식을 구현하는 방법으로 한 번 계산한 결과를 메모리 공간에 메모하는 기법
      * 같은 문제를 호출하면 메모했던 결과를 그대로 가져옴, 값을 기록해 놓는다는 점에서 캐싱(Caching)이라고도 함
      * 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미하므로, DP에 국한된 개념은 아님
  * bottom-up (상향식)
    * 결과 저장용 배열을 DP테이블이라고 부름
* 사용 조건
  * 최적 부분 구조 (Optimal Substructure) - 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있음
  * 중복되는 부분 문제 (Overlapping Subproblem) - 동일한 작은 문제를 반복적으로 해결해야 함
* 문제 풀이시 접근법
  * 먼저 기본 풀이 방법인 그리디, 구현, 완전탐색 등의 아이디어로 접근, 해결할 수 있는 지 확인
  * 불가능 하다면 다이나믹 프로그래밍으로 해결가능한지 고려
  * 작은 문제 조합해서 큰 문제를 해결할 수 있는 형태이고, 부분 문제가 중복되는지 확인
  * 우선 재귀함수로 비효율적인 완전탐색 프로그램을 작성한 뒤(탑다운), DP를 적용해 코드 개선


### JS구현
```
피보나치 수열
//top-down
const dp = new Array(101).fill(0);

const fibo = (n) => {
  if (n === 1 || n === 2) {
    return 1;
  } 
  
  if (dp[n]) {
    return dp[n];
  }
  
  dp[n] = fibo(n - 1) + fibo(n - 2);
  return dp[n];
}

//bottom up
const dp = new Array(100).fill(0);
dp[1] = 1;
dp[2] = 1;

for (let i = 3; i < 100; i++) {
  dp[i] = dp[i - 1] + dp[i - 2];
}

console.log(dp[99])

```

# 다익스트라 최단 경로 알고리즘

* 특정하 ㄴ노드에서 출발하여 다른 모드 노드로 가는 최단 경로를 계산
* 다익스트라 최단 경로 알고리즘은 음의 간선이 없을 때 정상적으로 동작
* 구현 과정
  1. 출발 노드를 설정
  2. 최단 거리 테이블을 초기화
  3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드 선택
  4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블 갱신
  5. 3번과 4번 과정 반복
* 그리디 알고리즘의 특징도 가짐, 매 상황에서 방문하지 않은 가장 비용이 적은 노드를 선택해서 임의의 과정을 반복
* 단계를 거치며 한 번 처리된 노드의 최단 거리는 고정되어 더 이상 바뀌지 않음
* 다익스트라 알고리즘을 수행한 뒤에 테이블에 각 노드까지의 최단 거리 정보가 저장
* 시간 복잡도는 O(V^2), V는 노드의 갯수, 일반적으로 코딩 테스트에서 전체 노드의 개수가 5,000개 이하라면 문제 해결 가능
* 노드가 5,000개 이상이라면 우선순위 큐 사용하여 개선된 다익스트라 알고리즘 => 시간 복잡도 O(ElogV) 

### JS구현
```
const [N, M] = [5, 6]; // 노드의 개수, 간선의 개수입력
const start = 1; // 시작 노드 입력
const graph = Array.from(new Array(N + 1), () => new Array() );
const visited = new Array(N + 1).fill(false);
const distance = new Array(N + 1).fill(Infinity);

for (let i = 1; i <= M; i++) {
  graph[a].push([b, c]); // a번 노드에서 b번 노드로 가는 비용 c
}

function getSmallestNode() {
  let minValue = Infinity;
  let index = 0; // 가장 최단 거리가 짧은 노드
  for (let i = 1; i <= N; i++) {
    if (distance[i] < minValue && !visited[i]) {
      minValue = distance[i];
      index = i;
    }
  }
  return index;
}

function dijkstra(start) {
  distance[start] = 0;
  visited[start] = true;
  for (let j = 0; j < graph[start].length; j++) {
    distance[graph[start][j][0]] = graph[start][j][1];
  }
  for (let i = 0; i < V - 1; i++) {
    let now = getSmallestNode();
    visited[now] = true;
    for (let node of graph[now]) {
      let cost = distance[now] + node[1];
      if (cost < distance[node[0]]) {
        distance[node[0]] = cost;
      }
    }
  }
} 

dijkstra(start);


// 우선 순위 큐를 사용하여 개선된 다익스트라 알고리즘
const [N, M] = [5, 6]; // 노드의 개수, 간선의 개수입력
const start = 1; // 시작 노드 입력
const graph = Array.from(new Array(N + 1), () => new Array() );
const distance = new Array(N + 1).fill(Infinity);
// visited  사용안함

for (let i = 1; i <= M; i++) {
  graph[a].push([b, c]); // a번 노드에서 b번 노드로 가는 비용 c
}
// getSmallestNode 함수 사용 안함

function dijkstra(start) {
  let queue = [];
  heapQ.push(queue, [0, start]) // headQ 따로 구현해야 될 듯, js는 라이브러리 없음
  distance[start] = 0;
  
  while(queue.length) {
    let [dist, now] = heapQ.pop();
    if (distance[now] < dist) continue;

    for (let i in graph[now]) {
      let cost = dist + i[1];
      if (cost < distance[i[0]]) {
        distance[i[0]] = cost;
        heapQ.push(queue, [cost, i[0]]);
      }
    }
  }
}

dijkstra(start);
// 나중에 힙 공부해서 수정 필수
```

# 플로이드 워셜 알고리즘

* 모든 노드에서 다른 모든 노드까지의 최단 경로를 모두 계산
* 다익스트라 알고리즘과 마찬가지로 단계별로 거쳐 가는 노드를 기준으로 알고리즘을 수행
* 2차원 테이블에 최단 거리 정보를 저장
* 다이나믹 프로그래밍 유형에 속함
* 각 단계마다 특정한 노드 k를 거쳐 가는 경우를 확인
* 시간 복잡도는 O(N^3)
### JS 구현
```
const [N, M] = [노드의 개수, 간선의 개수]
const graph = Array.from(new Array(N + 1), () => new Array(N + 1).fill(Infinity));
for (let i = 1; i <= N; i++) {
  for (let j = 1; j <= N; j++) {
    if (i === j) {
      graph[i][j] = 0;
    }
  }
} 
// 자기 자신에서 자기 자신으로 가는 비용은 0으로 초기화

for (let i = 0; i < M; i++) {
  graph[a][b] = c;
  // a에서 b로 가는 비용 c, 각 간선에 대한 정보 입력 받기
}

for (let k = 1; k <= N; k++) {
  for (let a = 1; a <= N; a++) {
    for (let b = 1; b <= N; b++) {
      graph[a][b] = Math.min(graph[a][b], graph[a][k] + graph[k][b]); 
      // 기존 a -> b 보다 k를 거쳐 가는 것이 비용이 덜 든다면 업데이트
    }
  }
}
```

# 서로소 집합

* 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조
* 서로소 집합 자료구조는 두 종류의 연산을 지원
  * 합집합 (Union) - 두 개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산
  * 찾기 (Find) -  특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산
* 서로소 집합 자료구조는 Union Find(합치기 찾기) 자료구조라고 불리기도 함
* 기본적인 구현 방법의 문제점
  * 합집합 연산이 편향되게 이루어지는 경우 찾기 함수가 비효율적으로 동작 (재귀함수 반복)
  * 최악의 경우에는 찾기(Find)함수가 모든 노드를 다 확인하게 되어 시간 복잡도가 O(V)가 됨
  * 찾기(Find)함수 최적화를 위한 방법으로 경로 압축(Path Compression)을 이용 (Find 함수를 재귀적으로 호출 후 부모 테이블 값을 바로 갱신)

### JS 구현
```
function findParent(parent, x) {
  if (parent[x] !== x) {
    return findParent(parent, parent[x]);
  }

  return x;
}

// Find 함수 최적화 -> 경로 압축 기법

function findParent(parent, x) {
  if (parent[x] === x) return x;
  returnm parent[x] = findParent(parent, parent[x]);
}

function unionParent(parent, a, b) {
  a = findParent(parent, a);
  b = findParent(parent, b);

  if (a < b) {
    parent[b] = a;
  } else {
    parent[a] = b;
  }
}

const [V, E] = [노드, 간선];
const parent = new Array(V + 1).fill(0);

for (let i = 1; i <= V; i++) {
  parent[i] = i; // 부모 테이블상에서 부모를 자기 자신으로 초기화
}

for (let i = 1; i < E; i++) {
  unionParent(parent, a, b)
}

for (let i = 1; i <= V; i++) {
  console.log(findParent(parent, i)); // 각 원소가 속한 집합 출력, 부모
}

for (let i = 1; i <= V; i++) {
  console.log(parent[i]); // 부모 테이블 내용 출력
}


// 사이클 판별
//findParent 함수와 unionParent 함수를 동일하게 사용함, 부모 배열까지도

let cycle = false;

for (let i = 0; i < E; i++) {
  if (findParent(parent, a) === findParent(parent, b)) {
    cycle = true;
    break;
  } else {
    unionParent(parent, a, b);
  }
}


if (cycle) {
  console.log("사이클 발생");
} else {
  console.log("사이클 발생하지 않음");
}

```

# 신장 트리

  * 그래프에서 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프
    * 모든 노드가 포함되어 서로 연결되면서 사이클이 존재하지 않는 조건은 트리의 조건이기도 함

##  최소 신장 트리 

  * 최소한의 비용으로 구성되는 신장 트리 찾기
  * 가장 대표적으로 크루스칼 알고리즘
    * 그리디 알고리즘으로 분류
    * 동작 과정  
      1. 간선 데이터를 비용에 따라 오름차순으로 정렬
      2. 간선을 하나씩 확인하며 현재의 간선이 사이클을 발생시키는지 확인
        * 사이클이 발생하지 않는 경우 최소 신장 트리에 포함
        * 사이클이 발생하면 최소 신장 트리에 포함시키지 않는다.
      3. 모든 간선에 대하여 2번의 과정을 반복
  * 시간 복잡도 O(ElogE), E는 간선의 개수

### JS 구현
```
// 크루스칼 알고리즘
//처음엔 union find알고리즘과 동일

function findParent(parent, x) {
  if (parent[x] !== x) {
    return parent[x] = findParent(parent, parent[x]);
  }

  return parent[x];
}

function unionParent(parent, a, b) {
  a = findParent(parent, a);
  b = findParent(parent, b);

  if (a < b) {
    parent[b] = a;
  } else {
    parent[a] = b;
  }
}

const [V, E] = [노드, 간선]
const parent = new Array(V + 1).fill(0);
const edges = [];

for (let i = 1; i <= V; i++) {
  parent[i] = i;
}

for (let i = 0; i < E; i++) {
  const [a, b, cost] = [출발, 도착, 비용] // 간선 정보
  edges[a].push([b, cost]);
}

edges.sort((a, b) => a[1] - b[1]) // 비용 오름차순으로 정렬
let result = 0;

for (let i = 1; i <= edges.length; i++) {
  const [b, cost] = edges[i];
  const a = i;

  if (findParent(parent, a) !== findParent(parent, b)) { // 사이클이 발생하지 않을 때만 집합에 포함
    unionParent(paretn, a, b);
    result += cost;
  }
}

console.log(result);
```

# 위상 정렬

* 사이클이 없는 방향 그래프의 모든 노드를 방향성에 거스르지 않도록 순서대로 나열
  * 진입차수(Indegree) - 특정 노드로 들어오는 간선의 개수
  * 진출차수(Outdegree)  - 특정 노드에서 나가는 간선의 개수
* DFS를 이용하는 방법과 큐를 이용해서 구현하는 방법이 있다.
* 큐를 이용한 위상정렬 동작과정
  1. 진입차수가 0인 모든 노드를 큐에 넣는다.
  2. 큐가 빌 때까지 다음 과정을 반복
    * 큐에서 원소를 꺼내 해당 노드에서 나가는 간선을 그래프에서 제거 (나가는 간선의 해당 노드의 진입 차수가 1만큼 줄어든다)
    * 새롭게 진입차수가 0이 된 노드를 큐에 넣는다.
* 결과적으로 각 노드가 큐에 들어온 순서가 위상 정렬을 수행한 결과와 같음
* 위상 정렬은 DAG(Direct Acyclic Graph)순환하지 않는 그래프 에서만 수행 가능
* 위상 정렬에서는 여러 가지 답이 존재 (한 단계의 큐에서 간선의 그래프가 2개 이상인 경우, 두 그래프에 순서에 따라 여러 답 존재)
* 모든 원소를 방문하기 전에 큐가 빈다면 사이클이 존재 (사이클에 포함된 원소는 큐에 들어갈 수 없음)
* 스택을 활용한 DFS를 이용해서 위상 정렬을 수행할 수 있음
* 시간 복잡도 O(V + E)

### JS구현
```
const [V, E] = [노드, 간선];
const inDegree = new Array(V + 1).fill(0);
const graph = Array.from(new Array(V + 1), () => new Array());
for (let i = 0; i < E; i++) {
  const [a, b] = [출발노드, 도착노드]
  graph[a].push(b);
  inDegree[b]++;
}

function topologySort() {
  const result = [];
  const queue = [];
  for (let i = 1; i <= V; i++) {
    if (inDegree[i] === 0) {
      queue.push(i);
    }
  }


  while (queue.length) {
    let now = queue.shift();
    result.push(now);
    for (let i of graph[now]) {
      inDegree[i]--;
      if (inDegree[i] === 0) {
        queue.push(i)
      }
    }
  }


  for (let i in result) {
    console.log(i);
  }
}
```

# 소수의 판별

* 약수의 성질을 이용해서 모든 약수가 가운데 약수(제곱근)를 기준으로 곱셈 연산에 대해 대칭을 이룬다
* 시간 복잡도 O(N^1/2), 약수의 성질을 이용하지 않으면 O(N^2)


### JS 코드 구현
```
// basic
function isPrimeNumber(x) {
  for (let i = 2; i <= Math.sqrt(x); i++) {
    if (x % i === 0) {
      return false;
    }
  }

  return true;
}

```

## 에라토스테네스의 체 알고리즘

* 특정 범위내에서 소수를 구하는 알고리즘
* 동작 과정
  1. 2부터 N까지의 모두 자연수를 나열한다.
  2. 남은 수 중에서 아직 처리하지 않은 가장 작은 수 i를 찾는다.
  3. 남은 수 중에서 i의 배수를 모두 제거한다. (i는 제거하지 않는다)
  4. 더 이상 반복할 수 없을 때까지 2번과 3번의 과정을 반복한다.
* 다수의 소수를 찾아야 하는 문제에서 효과적으로 사용가능
  * 하지만 소수 여부를 저장해야돼서 메모리가 많이 필요함
* 시간 복잡도 O(NloglogN)

### JS 코드 구현
```
const N; // 구하려는 범위의 수
const primes = new Array(N + 1).fill(true);

for (let i = 2; i < Math.sqrt(N) + 1; i++) {
  if (primes[i]) {
    let j = 2;
    while (i * j <= N) {
      primes[i * j] = false;
      j++;
    }
  }
}

console.log(primes)
```

# 투 포인터 (Two Pointer)

* 투 포인터 알고리즘은 리스트에 순차적으로 접근해야 할 때 두 개의 점의 위치를 기록하면서 처리하는 알고리즘을 의미합니다.
* 리스트에 담긴 데이터에 순차적으로 접근해야 할 때는 시작점과 끝점 2개의 점으로 접근할 데이터의 범위를 표현할 수 있다.
* 동작 과정
  1. 시작점과 끝점이 첫 번째 원소의 인데스(0)를 가리키도록 한다.
  2. 현재 부분 합이 M과 같다면, 카운트한다.
  3. 현재 부분 합이 M보다 작다면, end를 1 증가시킨다.
  4. 현재 부분 합이 M보다 크거나 같다면, start를 1 증가시킨다.
  5. 모든 경우를 확인할 때까지 2번부터 4번까지의 과정을 반복한다.

### JS구현
```
const N = 5; // 데이터의 개수
const M = 5; // 찾고자 하는 부분합
const data = [1, 2, 3, 2, 5];

let count = 0;
let intervalSum = 0;
let end = 0;

for (let start = 0; start < N; start++) {
  while (intervalSum < M && end < N) {
    intervalSum += data[end];
    end++;
  }

  if (intervalSum === M) {
    count++;
  }
  intervalSum -= data[start];
}

console.log(count) // 3
```

# 구간 합 (Interval Sum)

* 연속적으로 나열된 N개의 수가 있을 때 특정 구간의 모든 수를 합한 값을 계산하는 문제
* 접두사 합(Prefix Sum) (배열의 맨 앞부터 특정 위치까지의 합을 미리 구해 놓은 것)을 활용한 알고리즘 사용
  * N개의 수 위치 각각에 대하여 접두사 합을 계산하여 P에 저장
  * 매 M개의 쿼리 정보를 확인할 때 구간 합은 P[Right] - P[Left - 1]

### JS 구현
```
const N = 5;
const data = [10, 20, 30, 40, 50];

let sumValue = 0;
const prefixSum = [0];
for (let i of data) {
  sumValue += i;
  prefixSum.push(sumValue);
}

let left = 3;
let right = 4;

console.log(prefixSum[right] - prefixSum[left - 1])
```