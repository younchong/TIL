# 1. 요구 페이징

* 사용자가 페이지를 요구할때 메모리로 해당 페이지를 가져오는 것 (필수 프로그램은 올려두고, 나머지 프로그램들은 스왑영역등에 메모리 효율적 관리, 응답속도를 위해서)
* 페이지 테이블에 있는 페이지 테이블 엔트리에는 접근비트, 변경비트, 유효비트, 접근권한 비트가 있음
* 유효비트의 숫자에 따라 (0, 1) 주소필드값이 (프레임번호, 저장장치 내 주소) 변한다.
* 페이지 부재는 프로세스가 페이지 요청 시 그 페이지가 메모리에 없는 상황을 말하는 데, 이때 스왑영역에서 물리메모리로 이동시킴


# 2. 페이지 교체 알고리즘

* 페이지 갱신시 물리 메모리가 비어있지 않으면 스왑영역으로 보낼 페이지를 결정하는 알고리즘, 앞으로 사용 가능성이 적은 페이지를 대상 페이지로 설정하여 페이지 부재를 줄이고 성능 향상
* 종류
  * 간단한 알고리즘
    * 무작위 페이지 교체 알고리즘 - 특별한 로직없이 무작위로 선정, 가장 간단하게 구현할 수 있는 방식, 하지만 성능이 안좋아 거의 사용 안함
    * FIFO 페이지 교체 알고리즘 - 가장 먼저 들어온 페이지를 대상페이지로 선택하는 방식, 시간만 고려해서 성능 안좋음
  * 이론적 알고리즘
    * 최적 페이지 교체 알고리즘 - 앞으로 사용하지 않을 페이지를 스왑영역으로 옮기는 것, 메모리가 앞으로 사용할 페이지를 미리 확인하고 페이지 교체 선정시점부터 사용시점까지 가장 멀리 있는 페이지를 대상페이지로 선정. 성능은 좋지만 실제로 구현 불가
  * 최적 근접 알고리즘 - 과거의 데이터를 바탕으로 미래의 접근 패턴을 추정하는 알고리즘
    * LRU(Least Recently Used) 페이지 교체 알고리즘 - 메모리에 올라온 후 가장 오랫동안 사용되지 않은 페이지를 스왑영역으로 보냄(접근시간 기반, 카운터 기반, 참조비트시프트)
    * LFU(Least Frequent Used) 최소 빈도 알고리즘 - 페이지가 몇번 사용 되었는지를 기준으로 대상페이지 선정, 낭비되는 메모리 공간 많음
    * NUR(Not Used Recently) - 참조비트와 변경비트를 가지고 대상페이지를 선택하는 알고리즘, 앞선 알고리즘과 성능이 비슷하지만 불필요한 공간낭비문제를 해결한 알고리즘, 쉽게 구현가능하고 가장 많이 사용
    * FIFO 변형 알고리즘
      * 2차 페이지 교체 알고리즘 - 똑같이 큐를 쓰지만 페이지 접근시 페이지 부재없이 성공하면(메모리에 페이지가 있으면) 해당페이지를 큐 맨뒤로 이동(다시 대상페이지 우선순위에서 멀어짐)
      * 시계 알고리즘 - 원형큐와 대상 페이지를 가리키는 포인터를 사용하는 알고리즘, 참조비트를 참조하여 포인터가 대상 페이지를 고름, 대상 포인터와 참조비트만 추가해서 추가공간이 적게 들지만 알고리즘이 복잡하고 계산량이 많음

# 3. 스레싱과 프레임할당

* 잦은 입출력으로 페이지 부재가 많이 생겨 작업이 멈춘것 같은 상태를 스레싱(threshing)
* 멀티 프로그래밍 정도(동시에 실행하는 프로그램의 수)가 높으면 스레싱 발생
* 남아있는 프레임을 실행중인 프로세스에 적절히 나누어야 시스템 성능에 좋음 (적절한 프레임 할당)
* 프레임 할당 방식
  * 정적 할당 방식 - 프로세스 초기에 프레임을 나누고 이 후 이 것을 고정
    * 균등 할당 - 프로세스 크기와는 상관없이, 사용 가능한 프레임을 모든 프로세스에 동일하게 할당
    * 비례 할당 - 프로세스의 크기에 비례하여 프레임 할당
  * 동적 할당 방식 - 시시각각 변하는 요청을 수용하는 방식
    * 작업 집합 모델 - 최근 일정시간 동안 참조된 페이지들을 집합으로 만들고, 이 집합에 있는 페이지들을 물리 메모리에 유지
    * 페이지 부재빈도 - 페이지 부재 횟수를 기록하여 페이지 부재 비율을 계산 후 상한선, 하한선에 따라 상한선을 초과하면 프레임 추가, 하한선보다 내려가면 페이지 회수