# 모든 개발자를 위한 HTTP 웹 기본 지식 정리

## 인터넷 네트워크

  * 인터넷 통신
    * 어떻게 ? 두 컴퓨터는 IP를 이용해 패킷이라는 통신 단위로 데이터 전달
    * IP패킷에는 출발IP, 도착IP, 전송데이터 등이 있음
    * 문제점 - 비연결성(대상이 없어도 전송), 비신뢰성(중간소실이나 순서 보장 못함), 프로그램 구분 불가(같은 IP내 애플리케이션 구분 못함)

  * TCP / UDP
    * IP패킷의 문제점을 TCP를 이용해서 해결(연결지향TCP 3handshake, 데이터 전달 보증, 순서 보장)
    * UDP는 기능이 거의 없이 PORT가 존재하여 IP주소 내 프로그램 구분, 이외 다른 기능들 추가가능(최근)

  * PORT
    * IP주소내 프로그램을 구분할 수 있는 주소
    * IP가 목적지 서버를 제공한다면, PORT는 서버안에서 app 구분 (IP가 아파트라면 PORT는 동호수)

  * DNS (Domain Name System)
    * IP주소는 외우기 어려움, 변경 가능성
    * DNS서버에서 IP 주소를 도메인 이름에 각각 저장하여 요청시 제공하여 위 문제 해결
  
  * URI (Uniform Resource Identifier)
    * URL, URN으로 각각 주소와 이름으로 나타내지만, 주로 URL이 보편화
    * URL 전체 문법, 구성요소는 프로토콜, 호스트명, 포트 번호, 패스, 쿼리 파라미터
    * scheme :// [userinfo@] host(도메인명, IP주소) [:port][path(리소스 경로)][?query(key-value형식, ?시작 &추가)][#fragment(html 내부 북마크)]

  * 웹 브라우저 요청 흐름
    * 웹 브라우저가 HTTP요청 메시지 생성후 SOCKET 라이브러리로 TCP/IP 패킷을 생성하여 데이터 전달, 이후 서버에서 TCP/IP 패킷 속 HTTP요청 메시지를 확인, 같은 방식으로 응답, 웹 브라우저가 이를 받고 렌더링

  * HTTP (Hyper Text Transfer Protocol)
    * 요즘 서버 간 거의 모든 형태의 데이터를 주고 받을 때 사용
    * 클라이언트와 서버가 나누어진 구조를 가져, 독립적인 진화가 가능해짐 (클라이언트는 UI와 사용성, 서버는 비즈니스 로직과 데이터)
    * Statless 프로토콜로 클라이언트 상태 필요 없이 서버 확장성을 높히지만 추가적인 데이터를 연결시 보내야함
    * 웹 어플리케이션 설계시 최대한 stateless(무상태)로 설계하고, 최소한으로 stateful(상태유지)로 설계
  
  * 비연결성 (Connectionless)
    * HTTP는 기본적으로는 비연결성 모델로 서버자원을 효율적으로 사용
    * 매 연결시 TCP/IP 연결을 새로 해서 (3way handshake 시간 추가) 시간소모, 웹 브라우저 사이트 요청시 많은 자원 다운 필요
    * 요즘 HTTP 지속연결 사용, 최적화

  * HTTP 메시지
    * 구조 - start-line, HTTP헤더, empty-line, message body
      * start-line - request-line (HTTP 메서드, 요청 메시지, HTTP 버전) / status-line (HTTP 버전, HTTP 상태코드, 이유문구)
      * HTTP 헤더 - HTTP 전송에 필요한 모든 부가정보, 메시지 바디 제외 필요한 메타 정보가 들어있음
      * empty-line - 필수
      * message body - 실제 전송할 데이터, HTML문서, 이미지, 영상 등 byte로 표현할 수 있는 모든 데이터 전송가능

  * HTTP 메서드
    * API URI에서 URI는 리소스(상품,회원 등 본질)만 식별, 메서드를 통해서 무엇을 할지 결정
    * HTTP 메서드 종류
      * GET - 리소스 조회
      * POST - 새 리소스 생성, 요청 데이터 처리, 다른 메서드로 처리하기 애매한 경우 (메시지 바디에 담아서 많은 일 가능)
      * PUT - 리소스가 없으면 새로 생성, 있다면 대체, 클라이언트가 리소스 위치를 알고 URI 지정
      * PATCH - 리소스 부분 변경
      * DELETE - 리소스 제거
    * HTTP 메서드 속성
      * 안전 (Safe) - 여러번 호출해도 리소스를 변경하지 않음, GET, HEAD
      * 멱등 (Idempotent) - 몇번을 호출해도 결과가 같음 (외부 요인으로 변경되는 사항 제외), GET, PUT, DELETE, 자동 복구 메커니즘등에 사용
      * 캐시 (Cacheable) - 응답 결과 리소스를 캐시해서 사용가능, GET, HEAD, POST, PATCH 캐시가능, 실무에선 GET만

  * HTTP 메서드 활용
    * 클라이언트에서 서버로 데이터 전송하는 두가지 방식
      * 쿼리 파라미터 사용 - GET으로 주로 사용, 정렬 필터로 사용
      * 메시지 바디를 통한 데이터 전송 - POST, PUT, PATCH이용
    * 클라이언트에서 서버로 데이터 전송하는 4가지 상황
      * 정적 데이터 조회 - 쿼리 파라미터 없이 리소스 경로로 단순히 조회
      * 동적 데이터 조회 - 쿼리 파라미터 사용하여 조건 필터, 정렬 필터로 사용
      * HTML Form 통한 데이터 전송 - GET, POST만 지원, 메소드를 이용하여 HTML Form의 데이터 정보 제공, GET, POST만 사용해서 제약이 있음, 컨트롤 URI로 해소
      * HTML API 데이터 전송 - Form 사용하지 않는 모든 경우, 서버 to 서버, 앱 클라이언트, 웹클라이언트 , 클라이언트에서 서버로 바로 전송시
      * HTTP API 설계 예시
        * POST 기반 등롤 - 클라이언트가 서버에 요청하는것, 서버가 리소스 URI 생성하고 관리, 컬렉션, 주 사용
        * PUT 기반 등록 - 클라이언트가 리소스 URI알고 있고 관리도 함, 스토어, 거의 사용 안함

  * HTTP 상태코드
    * 상태코드란 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능
    * 앞자리 숫자를 보고 상위 상태코드로 해석해서 처리
      * 1xx (Information) - 요청이 수신되어 처리중, 거의 사용 안함
      * 2xx (Successful) - 클라이언트의 요청을 성공적으로 처리
        * 200 (OK) - 요청 성공
        * 201 (Created) - 요청 성공해서 새로운 리소스가 생성
        * 202 (Accepted) - 요청이 접수되었으나 처리 완료 안됨, 잘 사용 안함
        * 204 (No Content) - 서버가 요청을 성공했지만, 응답 페이로드 본문에 보낼 데이터가 없음 (문서 편집기 save 예시 등)
      * 3xx (Redirection) - 요청을 완료하기 위해 유저의 추가 조치 필요, 이 응답 결과에 location 헤더가 있으면, location 위치로 자동 이동됨
        * 영구 리다이렉션 - 특정 리소스의 URI로 영구적 이동
          * 301 (Moved Permanently) - 리다이렉트시 메서드가 GET으로 변하고, 본문이 제거될 수도 있음 (GET메소드 사용해서, 처음 POST한 걸 처음부터 다시 등록해야됨)
          * 308 (Permanent Redirect) - 301과 기능 같지만, 요청 메소드와 본문 내용 유지 (다시 재등록 안해도 됨, 그러나 실무에선 거의 사용안함, URL바뀌면 내부 전달 데이터도 거의 바뀜)
        * 일시적인 리다이렉션 - 리소스의 URI가 일시적으로 변경
          * 302 (Found) - 리다이렉트시 요청 메서드가 GET으로 변하고, 본문 내용 제거될 수 있음 (MAY, 그럴수도 안그럴수도 애매함) 하지만 가장 기본값, 실무에서 주로 쓰임
          * 307 (Temporary Redirect) - 302와 내용 같지만, 요청메서드와 본문 내용 유지
          * 303 (See Other) - 302와 내용같지만 명확하게 메서드가 GET으로 변경
          * PRG (Post, Redirection, Get) 일시적 리다이렉션 예시, 오류를 줄일 수 있음
        * 기타 리다이렉션
          * 300 (Multiple Choice) - 안씀
          * 304 (Not Modified) - 캐시를 목적으로 사용, 캐시가 오래돼서 리소스를 재요청시, 서버에서 리소스가 변하지 않음을 알려주고 캐시를 그대로 사용해도 된다고 알려줌, 클라이언트는 저장된 캐시 재사용 (응답에 메시지 바디 사용 안함)
      * 4xx (Client Error) - 오류 원인이 클라이언트에 있는 오류
        * 400 (Bad Request) - 클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음 (요청 구문, 문법, 파라미터 등)
        * 401 (Unauthorized) - 클라이언트가 해당 리소스에 대한 인증이 필요 (특정 리소스에 접근할 수 있는 권한, 권한 부여가 필요)
        * 403 (Forbidden) - 서버가 요청을 이해했지만 승인 거부, 인증 (authentication)자격 증명은 있지만 접근 권한이 불충분한 경우
        * 404 (Not Found) - 요청 리소스를 찾을 수 없음, 서버에 리소스가 없거나, 클라이언트가 권한 부족 리소스에 접근하려할 때 숨기고 싶을 때
      * 5xx (Server Error) - 서버에 문제가 있을 때만 사용
        * 500 (Internal Server Error) - 서버 내부 문제로, 애매할때 주로 사용
        * 503 (Service Unavailable) - 서비스 이용 불가, 서버가 일시적 과부하 또는 다른 작업으로 잠시 요청 처리 불가시

  * HTTP 헤더 - HTTP 전송에 필요한 모든 부가 정보 제공 (메시지 바디의 내용, 메시지 바디의 크기, 압축, 인증, 요청 클라이언트, 서버 정보, 캐시 관리 정보...)
  * HTTP BODY (RFC2616 과거 버전) - 메시지 본문은 엔티티 본문을 전달하는 데 사용하고, 엔티티 본문은 요청이나 응답에서 전달할 실제 데이터를 담는다. 엔티티 헤더는 엔티티 본문의 데이터를 해석할 수 있는 정보 제공
  * HTTP BODY (RFC7230 현재 버전) - 메시지 본문으로 표현 데이터 전달 (엔티티에서 표현으로 바뀜, 표현은 표현 메타데이터 + 표현 데이터)
    * 표현
      * Content-Type - 표현 데이터의 형식 (미디어타입, 문자인코딩)
      * Content-Encoding - 표현 데이터의 압축 방식, 데이터를 전달하는 곳에서 압축 후 인코딩 헤더추가, 압축정보 제공(gzip, deflate ...)
      * Content-Language - 표현 데이터의 자연언어 (ko, en ...)
      * Content-Length - 표현 데이터의 길이, 바이트 단위
    * 협상 (Content Negotiation) - 클라이언트가 선호하는 표현 요청 (미디어타입, charset 문자 인코딩, Encoding 압축 인코딩, Language 자연 언어 등), 협상 헤더는 요청시에만 사용
    * 협상 우선순위 - 협상에서 복잡한 경우 시 우선순위로 문제 해결, Quality Values(q)값 사용, 0 - 1 클수록 우선순위, 생략하면 1, 구체적인 것이 우선하고 그걸 기준으로 미디어 타입을 맞춤
    * 전송 방식
      * 단순 전송 (Content-Length) - content 길이를 알 수 있을 때 사용, 한번에 요청하고 한번에 받는 방식
      * 압축 전송 (Content-Encoding) - 압축해서 용량을 줄여 전송
      * 분할 전송 (Transfer-Encoding) - content를 나눠서 byte정보랑 같이 전송, 전송 시 content-length 같이 제공하면 안됨
      * 범위 전송 (Content-Range) - 범위를 나누고 지정해서 전송
    * 일반 정보
      * From - 유저 에이전트의 이메일 정보, 잘 사용 안함
      * Referer - 현재 요청된 페이지 이전 웹 페이지 주소, 유입 경로 분석 가능, 요청에서 사용
      * User-Agent - 클라이언트의 웹 브라우저 정보, 애플리케이션 정보, 통계 정보로 주로 이용, 어떤 종류의 브라우저에서 장애가 발생하는지 파악 가능, 요청에서 사용
      * Server - 요청을 처리하는 ORIGIN 서버의 소프트웨어 정보, 응답에서 사용, ORIGIN서버란 HTTP는 중간에 여러 proxy서버를 거치는데 이때 실제 나의 요청에 응답해주는 서버, 끝에 있는 서버
      * Date - 메시지가 발새한 날짜와 시간
    * 특별한 정보
      * Host - 요청한 호스트 정보 (도메인), 필수 요건, 요청에서 사용, 하나의 IP가 여러 도메인이 적용되어 있을 때, 그때 구분을 해줌, 어느 도메인에서 처리할지
      * Location - 페이지 리다이렉션에 사용, 3xx 응답결과에서 사용되는 location 값으로 리다이렉션을 위한 대상 리소스를 가리킴
      * Allow - 허용 가능한 HTTP 메서드, URI경로가 있는데 허용 메소드가 아닐 경우, Allow에 있는 메소드만 사용 가능, 서버에서 구현 잘 안돼있음
      * Retry-After - 유저 에이전트가 요청을 하기까지 기다려야 하는 시간, 실제로 사용하기 쉽지 않음
    * 인증 - Authorization 클라이언트 인증 정보를 서버에 전달, WWW-Authenticate 리소스 접근시 필요한 인증방법 정의
    * 쿠키 - HTTP는 stateless 프로토콜이므로 쿠키 사용안하고 모든 요청에 사용자 정보를 포함하면 개발하기 힘들고 불편
      * Set-Cookie - 서버에서 클라이언트로 쿠키 전달(응답)
      * Cookie - 클라이언트가 서버에서 받은 쿠키를 저장하고, HTTP 요청시 서버로 전달
      * 쿠키 사용시 웹 브라우저가가 서버 요청 전에 쿠키 저장소를 자동으로 탐색해서 쿠키 값을 가져와서 서버로 보냄, 모든 요청에 자동으로 쿠키 정보 포함
      * 최소한의 정보만 사용 (세션 id, 인증 토큰), 보안에 민감한 데이터는 저장금지
      * 주 사용처는 사용자 로그인 세션 관리, 광고 정보 트래킹 등
      * 생명 주기 - 만료 날짜 생략하면 브라우저 종료시까지만 유지 (세션 쿠키), 만료 날짜 입력하면 해당 날짜까지 유지
      * 도메인 (Domain) - 명시하면 명시한 문서 기준 도메인과 서브 도메인도 포함, 생략하면 현재 도메인만 적용 (하위 도메인 접근 불가)
      * 경로 (Path) - 명시한 경로 포함 하위 경로 페이지만 쿠키 접근, 일반적으로 루트로 지정 (한 도메인 안에서 쿠키 다 전송해야 원할)
      * 보안 (Secure, HttpOnly, SameSite) - Secure적용시 https인 경우에만 전송, HttpOnly는 HTTP 전송에만 사용, 자바스크립트에서 접근 불가, SameSite는 요청 도메인과 설정 도메인이 같은 경우만 쿠키 전송
    * 캐시 - 웹 브라우저에서 서버로 이미지 등의 데이터를 요청시 캐시가 있다면 데이터를 다시 다운받지 않아도 됨,캐시를 이용해 네트워크 사용량을 줄이고 로딩 속도를 빠르게 만들 수 있음
      * 캐시 시간 초과 - 캐시는 유효 시간을 갖고 있고, 유효 시간이 초과되면, 서버를 통해 데이터를 다시 조회하고 캐시를 갱신
        * 유효 시간 초과 시 두가지 상황
          * 서버에서 기존 데이터 변경
          * 서버에서 기존 데이터 유지 - 그대로 사용 가능, 그러나 클라이언트와 서버의 데이터가 같다는 확인 필요 
            * 검증 방식 - 검증 헤더와 조건부 요청
              * Last-Modified 와 If-Modified-Since - 날짜 기반 로직, 1초 미만 캐시 조정 불가, 날짜는 다르지만 데이터 결과가 같은 경우도 바뀜
              * ETag 와 If-None-Match - ETag만 보내서 같으면 유지, 다르면 다시 받기, 캐시 제어 로직을 서버에서 완전히 관리
      * 캐시 제어 헤더
        * Cache-Control - 캐시 제어
          * 지시어
            * max-age : 캐시 유효시간, 초 단위
            * no-cache : 항상 원(origin) 서버에 검증하고 사용, 접근 실패시 프록시 서버에서 캐시 데이터 반환
            * no-store : 데이터에 민감한 정보가 있어 저장하면 안됨(메모리에서 사용하고 최대한 빨리 삭제)
            * must-revalidate : 캐시 만료 후 최초 조회시 원서버에서 검증, 원 서버 접근 실패시 반드시 오류 발생
        * Pragma - 캐시 제어(하위 호환)
        * Expires - 캐시 만료일 지정(하위 호환), 정확한 날짜로 지정, 지금은 더 유연한 max-age 권장
      * 프록시 캐시 - 웹 브라우저(private 캐시)에서 멀리 떨어져 있는 원 서버에서의 데이터 전송시간을 줄이기 위해 클라이언트에게 가까운 한 곳에 프록시 캐시 서버(public 캐시)를 만들어 공용으로 사용하여 데이터 전송시간을 줄임
      * 캐시 무효화  - 확실한 캐시 무효화 응답 위해서 Cache-Control에선 no-cache, no-store, must-revalidate와 Pragma에선 no-cache 넣어주면 확실하게 대응됨

