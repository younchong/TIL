# 에러 처리

  * 발생한 에러를 처리하지 않고 방치하면 프로그램은 강제 종료된다.
  * try...catch...finally 문으로 에러 처리 가능
    * finally문은 불필요하다면 생략가능
    * catch문도 생략 가능하지만, catch문 없는 try문은 의미가 없다.
  * Error 생성자 함수로 에러 객체를 생성한다고 에러가 발생하는 것은 아니다. throw로 생성된 에러 객체를 던져야함.
  * throw된 에러를 캐치하여 적절히 대응하면 프로그램이 강제 종료되지 않고, 코드의 실행 흐름을 복구할 수 있다.

# 에러의 전파

  * 에러는 호출자 방향으로 전파된다. 
  * 콜스택의 아래 방향 (실행 컨텍스트가 푸시되기 직전에 푸시된 실행컨텍스트 방향)으로 전파된다.
  * 비동기 함수인 setTimeout, setInterval이나 프로미스 후속 처리 메서드 콜백 함수는 호출자가 없다.
    * 이 함수들은 태스큐나 마이크로 태스크 큐에서 일시 저장되어 있다가 이벤트 루프에 의해서 콜스택이 모두 비어졌을 때 저장된다.
    * 이때 콜스택에 저장된 콜백함수의 실행 컨텍스트는 콜 스택의 가장 하부에 존재하게 된다. 따라서 에러를 전파할 호출자가 존재하지 않는다.
  
# 모듈

  * 일반적으로는 모듈은 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각을 말합니다.
  * 기능 기준으로 파일 단위로 분리하고, 모듈이 성립하기 위해선 자신만의 파일 스코프(모듈 스코프)를 가질 수 있어야한다.
    * 자신만의 파일 스코프를 가져서 캡슐화 되어있고, 개별적 존재로 애플리케이션과는 분리되어 존재한다.
    * 하지만 공개가 필요한 자산에 한정하여 명시적으로 선택적 공개가 가능하다. export를 통해서
    * 반대로 공개한 자산 중 일부 또는 전부를 선택해 자신의 스코프 내로 불러들여 재사용할 수 있다. import를 통해서
  * 모듈을 통해서 코드의 단위를 명확히 분리하여 애플리케이션을 구성할 수 있고, 재사용성이 좋아서 개발 효율성과 유지보수성을 높힐 수 있다.

# 자바스크립트와 모듈

  * CommonJS
    * JS everywhere를 목적으로 한 자발적 워킹 그룹
    * 단순하고 직관적이고, 파일을 비동기적으로 로딩 가능한 서버환경에 적합
    * script 파일 로딩시 blocking 발생하는 브라우저 환경에서는 성능저하 발생
    * Node.js는 CommonJS를 채택했고, 독자적인 진화를 거쳐 거의 비슷해짐, 기본적으로 CommonJS 사양을 따름.
  * AMD (Asynchronous Module Definition)
    * CommonJS가 브라우저 환경에서의 비동기 모듈 로드에 대한 관심이 저조한 것에 대한 반감으로 분리되어 나온 집단
    * 브라우저 환경에서 비동기 네트워크 로딩 처리 가능, lazy loading처리에도 용이한 장점
    * 코드가 복잡하고 의존성 주입 개념 이해하기 난이도가 높고, 주입 소스의 순서를 잘 지켜야함.
  * ES6 Module (ESM)
    * 클라이언트 사이드 JS에서도 동작하는 모듈 기능 추가. IE를 제외한 대부분 브라우저에서 동작가능
    * script 태그에 type="module" 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작함.
    * 기본적으로 strict mode가 적용됨.
    * 파일 자체의 독자적인 모듈 스코프를 갖는다. 
    * import, export 최상단에서만 사용가능 (depth가 있으면 안된다.)
