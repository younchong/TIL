# 제너레이터

  * 제너레이터는 코드 블록의 실행을 일시 중지했다가 필요한 시점에 재게할 수 있는 특수한 함수
  * 특징
    * 함수 호출자에게 함수 실행의 제어권을 양도
    * 함수 호출자와 함수의 상태를 주고 받음 (양방향)
    * 제너레이터 함수를 호출하면 제너레이터 객체를 반환한다.
  * 제너레이터 함수를 정의하려면 function 키워드와 함수이름 사이에 *(애스터리스크)를 위치시키면 된다. (function* gen)
  * 제너레이터 함수가 호출시 반환한 제너레이터 객체는 이터러블이면서 이터레이터이다.
    * 이터러블(iterable)은 순환문 예를들어 for...of에서 value들이 순환되는 것과 같은 iteration 동작을 정의하거나 사용자 정의하는 것을 허용한다.
    * 이터레이터(iterator)는 객체가 규칙에 맞는 next 메소드를 가지고 있는 객체를 말한다.
      * 규칙은 done(boolean)으로 끝났음을 알리고, value로 iterator로 부터 반환되는 값을 알려줌.

# 제너레이터의 일시 중지와 재개

  * 제너레이터 함수는 일반함수와 같이 코드 블록의 모든 코드를 일괄 실행하는 것이 아니라 yield 표현식까지만 실행한 후 함수 실행을 중지시키거나, 뒤에 표현식의 평가 결과를 제너레이터 함수 호출자에게 반환한다.
  * 함수 호출자가 next 메서드를 호출해서 yield 표현식까지 실행되고 일시 중지된다. 이후 함수의 제어권이 다시 함수 호출자로 양도됨.
  * next메서드는 value와 done 프로퍼티를 갖는 iterator result 객체를 반환
    * value는 yield표현식에서 뒤에 값이 할당
    * done프로퍼티에는 제너레이터 함수가 끝까지 실행되었는지를 나타내는 불리언 값이 할당된다.

# async/await

  * ES8에서 비동기처리를 간단하고 더 가독성 좋게 처리하기위해서 async/await가 도입되었다.
  * async/await를 사용하면 비동기 처리 결과를 후속 처리할 필요 없이 마치 동기처럼 프로미스를 사용할 수 있다.
  * try ... catch 문을 사용해서 에러 처리를 할 수 있다.
    * 프로미스를 반환하는 비동기 함수를 명시적으로 호출할 수 있어서 호출자가 명확하기 때문이다.
    * 일반적으로는 비동기 함수의 콜백함수를 호출한 것은 비동기 함수 자체가 아니라서 에러 캐치 못함
