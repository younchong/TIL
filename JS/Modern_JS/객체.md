# chap 4. 객체: 기본

대괄호 표기법은 점 표기법과 다르게 

object[key], object.key

key가 런타임 환경에서 평가돼서 코드를 유연하게 작성할 수 있다.

대괄호 표기법이 이름과 값의 제약을 없애주기 때문에 점 표기법보다 강력하다. 하지만 번거롭기 때문에 프로퍼티 이름이 처음에 확정되고 단순하면 점표기법을 사용하고 복잡한 상황으로 변경되어 가면서 대괄호 표기법으로 변경된다.

### 객체의 정렬방식

정수 프로퍼티일 경우엔 자동으로 정렬되고, 그외엔 추가 순서대로 정렬된다.

정수 프로퍼티란 변형없이 정수에서 왔다 갔다 할 수 있는 문자열 (’+49’, ‘1.2’ 이런건 안됨)


### 참조에 의한 객체복사

객체는 참조에 의해 할당되고 복사된다.

변수엔 객체 자체가 아닌 메모리상의 주소인 참조가 저장된다.

따라서 객체가 할당된 변수를 복사하거나 함수의 인자로 넘길 땐 객체가 아닌 객체의 참조가 복사된다.


### 가비지 컬렉션의 기준

reachability를 기준으로 삭제할지 말지 정한다.

자바스크립트 엔진내에서 끊임없이 가비지 컬렉터가 동작하면서 모든 객체들을 모니터링하면서 도달할 수 없는 객체들을 삭제한다.

### 가비지 컬렉션 내부 알고리즘: mark-and-sweep

- 루트정보를 수집하고 mark합니다.
- 루트가 참조하고 있는 객체를 방문하고 마크하고 반복합니다.
- 마크되어 있지 않은 객체를 삭제한다.

### 최적화 기법

- generational collection (세대별 수집)
- incremental collection (점진적 수집)
- idle-time collection (유휴 시간 수집)

### 메서드와 this

this는 런타임에 결정된다. (일반함수, dot notation, method, binding)

### new 연산자와 생성자 함수

new.target을 사용하면 new 연산자를 사용했는지 아닌지 알 수 있다.

생성자 함수는 new와 함께 호출되면서 내부에 this가 암시적으로 만들어지고 this가 반환된다.

### 생성자와 return문

생성자 함수는 보통 return문이 없고, 반환해야될 것들은 this에 저장되고 this는 자동으로 반환되기 때문에 반환문을 명시적으로 써 줄 필요가 없습니다.

만약 return문을 쓴다면

- 객체를 반환한다면 this 대신 객체가 반환된다.
- 원시형을 반환한다면 무시되고 this가 반환됨.

하지만 일반적으론 생성자함수에는 return문이 거의 없다.

괄호를 생략해도 생성자 함수는 정상 작동하지만 좋은 스타일은 아니다.

### 옵셔널 체이닝 ?.

?. 앞의 평가 대상이 undefined나 null이면 평가를 멈추고 undefined를 반환합니다.

옵셔널 체이닝을 남용하지 말자.

필수값이 아닌 곳에 옵셔널 체이닝을 사용해서 확인해야 나중에 디버깅시 쉽게 파악할 수 있다.

### 단락 평가 (short circuit)

옵셔널 체이닝 ?. 앞에 값이 없으면 즉시 평가를 멈춘다. 이를 단락 평가(short circuit)이라 한다.

그래서 옵셔널 체이닝 오른쪽에 있는 값들은 평가가 멈췄을 때 일어나지 않는다.

### ?.(), ?.[]

옵셔널 체이닝을 이용해서 함수 호출과 객체 프로퍼티에 접근이 가능하다.

delete와 조합해서 사용할 수도 있다.

```jsx
delete user?.name;
```

### 심볼형

심볼은 유일한 식별자를 만들고 싶을 때 사용한다.

심볼은 이름이 같아도 값은 다르다. 

```jsx
Symbol('id') !== Symbol('id');
```

 같길 원한다면 전역 레지스트리를 사용

### symbols in literal

심볼을 리터럴에서 사용하려면 대괄호를 사용해서 사용해야 한다.

```jsx
let id = Symbol('just');

const user = {
  [id]: 'like',
  name: 'kim'
}
```

그렇지 않으면 string으로 판단

### 심볼은 for…in에서 배제된다.

심볼형 프로퍼티 숨기기 (hiding symbolic property)라 불리는 이 원칙 덕분에 외부 스크립트나 라이브러리가 심볼형 키를 가진 프로퍼티에 접근하지 못한다. 

그러나 object.assign은 심볼 프로퍼티도 모두 복사한다.

### 전역 심볼

Symbol.for(key)를 이용해서 만든 전역 심볼 레지스트리 안에 있는 심볼을 전역 심볼이라 부른다.

애플리케이션에서 광범위하게 사용해야 하는 심볼이면 전역 심볼을 사용한다.

Symbol.for(key) ⇒ key 값의 심볼이 없으면 심볼을 만들고, 있다면 심볼을 읽는다.

### Symbol.keyFor

Symbol.keyFor를 사용해서 전역 심볼 레지스트를 뒤져서 해당 이름의 심볼을 찾는다.

심볼을 완전히 숨길 수는 없다.

Object.getOwnPropertySymbol(obj)를 사용하면 모든 심볼을 볼 수 있고

Reflect.ownKeys(obj)는 심볼형 키를 포함한 객체의 모든키를 반환해준다.
