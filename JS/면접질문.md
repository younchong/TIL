# 기본 단골 질문

# 브라우저 저장소에 대해서 설명해 보세요
<details>
<summary>답변</summary>

* 로컬 스토리지와 세션 스토리지는 HTML5에서 추가된 저장소로 key와 value를 저장할 수 있다.
* 로컬 스토리지는 사용자가 지우지 않으면 브라우저에 계속 남는다.  (만료 기간 지정) 5MB
* 세션 스토리지는 브라우저 닫으면 지워짐 
  * 세션은 방문자가 웹서버에 접속해있는 상태를 하나의 단위로 보고 그것을 세션이라고 함.
* 쿠키는 로컬 스토리지와 세션 스토리지 이전의 브라우저의 저장소 역할을 했고, 만료기한이 있는 저장소이다. 동일하게 key와 value로 저장, 용량이 더 작다. 약 4KB
  * 쿠키는 브라우저에 저장되고, 세션은 접속중인 웹서버에 저장된다.
  * 보안, 쿠키 취약, 세션 비교적 좋음
  * 속도, 쿠키 빠름, 세션 느림

* 캐시 - 데이터나 값을 미리 복사해 놓는 임시 장소, 캐시는 캐시의 접근 시간에 비해 원래 데이터를 접근하는 시간이 오래 걸리는 경우나 값을 다시 계산하는 시간을 절약하고 싶은 경우에 사용
  * 브라우저에 저장된 캐시는 네트워크 사이 주고 받는 데이터를 캐시해 놓는 것이 흔하다. (headers, body 등...)
  * 최근 방문한 사이트를 캐시에 저장해두거나, 인터넷 제공업체들과 대규모 네트워크에서 인기있는 웹페이지의 캐시를 프록시 서버에 저장해서 빠르게 응답해서 네트워크 대역폭을 아낀다.

* 쿠키, 세션 flow
  * 브라우저가 서버에 로그인 요청
  * 서버에서 세션확인 후 브라우저에 세션 정보의 ID값을 쿠키에 포함하여 보냄 (상황에 따라 보내는 정보 다름)
  * 쿠키를 전달받은 브라우저는, 앞으로 같은 도메인에 접속 요청을 보낼 경우, Header에 쿠키 포함
  * 인증 권한이 필요한 다른 요청을 서버로 보냄
  * 서버는 쿠키에 저장된 세션 ID를 이용해서 사용자 인증 정보 검증
    * 검증 통과시, 요청 정상 처리 진행 후 응답
    * 검증 실패시, 요청 오류 처리 진행 후 응답

* JWT flow
  * 클라이언트에서 서버로 사용자 정보와 함께 로그인 요청
  * 서버에서는 사용자 정보 검증 후 토큰 발급
  * 클라이언트에서 토큰을 보관하고, 사용자 인증이 필요한 요청을 보낼때 토큰을 함께 보냄
    * 일반적으로 헤더에 추가해서 보냄.
  * 서버에서 토큰을 이용해서 사용자 검증 이후 요청에 대한 처리 진행
  * 장점
    * 서버측 작업이 stateless
    * 클라이언트가 토큰 관리해서, 서버의 스케일링이 더 쉽다.
    * Cross Domain 이슈 관계없이 검증
  * 단점
    * 토큰 도난 이슈, 토큰의 유효 기간을 짧게 설정하고 자주 갱신해야한다.
    * Cross Site Scripting (XSS)에 대한 위험이 있다. 
  

ex) 로컬 스토리지, 세션 스토리지, 쿠키 각각 설명
ex) 로컬 스토리지와 쿠키의 차이점 설명
웹스토리지를 아는지 ⇒ 세션스토리지와 로컬 스토리지 차이
쿠키와 세션 차이
</details>

# 자바스크립트 this란?
<details>
<summary>답변</summary>

* 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수이다.
* 4가지 함수가 호출되는 방식에 따라서 this가 가리키는 것이 달라진다.
  1. 일반 함수 호출시 - global, window(browser에선) 전역객체 / undefined (use strict 모드시)
  2. 메서드로 호출시, dot notation - 메서드를 호출하는 객체를 가리킨다.
  3. 생성자 함수에서 호출시 - 생성자 함수를 가리킴
  4. call, apply, bind를 이용한 binding - 특정객체에 바인딩된 this를 가리킴
* call, bind, apply를 통해서 this를 바인딩할 수 있다.
* 화살표함수내에서 가리키는 this는 상위 컨텍스트에 있는 함수의 this이다.
</details>

# 자바스크립트 이벤트 관리 방법? 보통 어떤 식으로 이벤트를 설계해야 하는지?
<details>
<summary>답변</summary>

* 이벤트 캡쳐링은 부모에서 발생한 이벤트가 자식으로 전해지는 것 (캡쳐링 사용하는 일은 거의 없다.)
  * addEventListener(..., {capture: true}) 캡쳐링단계에서 핸들러 동작, false가 디폴트값
* 버블링이란, 이벤트가 발생했을 때 부모로 전달되어가는 것, 즉 자식에서 부모로 전파 
  * event.stopPropagation()으로 이벤트 버블링을 막을 수 있다.
* 이벤트 위임(Event Delegation)이란 상위 요소에서 하위 요소의 이벤트를 제어하는 방식을 말합니다.
ex) 이벤트 캡처링 & 버블링
ex) 이벤트 등록 & 해제
ex) 이벤트 위임 방식 등
</details>

# 자바스크립트 비동기 처리에 대한 설명
<details>
<summary>답변</summary>

* JS에서 비동기처리는 콜백함수, Promise 그리고 async/await가 있습니다.
* 초기 비동기 처리 방식인 콜백함수는 다수의 중첩으로 발생되는 콜백헬이나 에러처리가 힘들다는 단점이 있습니다.
* 이러한 단점을 보완하기 위해서 ES6부터 도입된 Promise는 pending, fulfilled 그리고 Rejected 상태를 갖고 비동기 처리를 합니다.
* 더 읽기 좋고 이해하기 좋은 흐름을 위해서 async/await이 es8에 도입해서 비동기 처리가 있는 하는 함수 앞에 async를 붙히고 비동기 처리 하는 코드 앞에 await를 붙혀서 사용합니다.
* 최신 업데이트로 async없이 await만으로도 비동기 처리할 수 있게 됐습니다.

* 자바스크립트의 비동기처리란, 특정 코드의 연산이 끝날 때까지 코드의 실행을 멈추지 않고, 다음 코드를 먼저 실행하는 방식
* 콜백함수는 JS에서 비동기처리를 위해 사용되는 패턴, 함수의 처리 순서를 보장하기 위해 함수를 중첩해서 사용되는 경우 콜백헬이 발생할 수 있고, 에러처리가 힘들다.
* 프로미스는 es6부터 콜백의 단점들을 보완하기 위해 만든 비동기 처리에 사용되는 객체
  * 비동기 처리에 성공하면 resolve 메소드 호출
  * 비동기 처리에 실패하면 reject 메소드 호출
  * 후속처리 메소드로 then, catch가 있다.
* 비동기 처리가 있는 함수 앞부분에 async를 붙히고, 함수 내부 Promise 앞부분에 await를 붙혀서 동기적인 흐름을 내부에서 만들 수 있다.
* 자바스크립트 엔진은 싱글 스레드임에도 비동기 처리를 할 수있는 이유는, 자바스크립트 엔진이 구동하는 환경인 브라우저나 Node.js가 태스크 큐와 이벤트 루프를 이용해서 멀티 스레드 환경에서 비동기처리하기 떄문이다.
ex) 콜백, 프로미스, async await
ex) 비동기 처리의 특성 및 에러 처리 방법?
</details>

# virtual DOM과 Shadow DOM에 대하여
<details>
<summary>답변</summary>

  * virtual DOM은 UI의 이상적인 또는 가상적인 표현을 메모리에 저장하고 React DOM과 같은 라이브러리에 의해 실제 DOM과 동기화하는 프로그래밍 개념입니다.
  * React에서 새로 렌더링해야될 때 새롭게 그린 virtual DOM과 이전 virtual DOM을 비교해서 바뀐 부분만 렌더링합니다.
  * Shadow DOM은 숨겨진 DOM트리가 통상적인 DOM트리 요소에 부착하는 방법을 제공합니다.
    * 숨겨진 DOM트리로, HTML상에 나타나지 않는다.
    * DOM은 마크업 문서에서 나타나는 여러가지 요소들과 텍스트 문자열을 나타내는 연결된 노드들의 트리같은 구조를 말합니다.
      * 웹의 document를 구성하는 structure와 content를 나타내는 데이터
      * 웹 다큐먼트를 위한 프로그래밍 인터페이스, 노드나 object로 나타내는데, 프로그래밍 언어가 이를 통해서 조작할 수 있다.
      * 마크업 언어는 문서가 화면에 표시되는 형식을 나타내거나 데이터의 논리적인 구조를 명시하기 위한 규칙들을 정의한 언어이다.
        * 예시 - HTML, 마크다운, style태그 

  * React Fiber는 React16에서의 새로운 조정(Reconciliation)엔진, 프로그램의 주요 목표는 virtual DOM의 증분 렌더링을 활성화 하는 것입니다.
</details>

# 바벨이란?
<details>
<summary>답변</summary>

  * 바벨은 자바스크립트 컴파일러로 주로 ES6+를 예전 버전으로 바꿔주는 역할을 한다.
  * 자바스크립트 최신 문법을 지원하지 않는 브라우저 환경에서 (IE나 예전 브라우저들) JS최신 문법을 지원하는 문법으로 변경해주는 것
  * 주 역할
    * 문법 변환 (transform syntax)
    * Polyfill features that are missing in your target environment (through a third-party polyfill such as core-js)
    * source code 변환

  ## 폴리필이란?
  
    * 웹 개발에서 기능을 지원하지 않는 웹 브라우저상의 기능을 구현하는 코드

</details>

# 렉시컬 환경이란?
<details>
<summary>답변</summary>

* 모든 코드들은 실행 컨텍스트에서 관리가 되는데, 실행 컨텍스트 내부의 렉시컬환경에서 식별자와 스코프가 관리가 된다.
* 렉시컬 환경은 식별자들에 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트 입니다.
* Environment Record, Outer Lexical Environment
* 렉시컬환경 설명 ⇒ 설명 후 렉시컬환경과 동적환경의 차이를 아느냐?

실행컨텍스트가 무엇인지 ⇒ 실행컨텍스트 안에는 어떻게 구성되어있는지
* 실행 컨텍스트는 소스코드를 평가하고, 소스코드들이 실행되기 위한 환경이다.
* stack으로 코드 실행 순서 관리를 구현했고, 식별자를 관리하는 렉시컬 스코프로 구성
* 실행 컨텍스트에는 variable object(함수 컨텍스트일 경우는 Activation Object), outerEnvironmentReference, thisValue 세가지 객체 프로퍼티를 가지고 있다.
* 스코프 체인이란, 해당 전역 또는 함수가 참조할 수 있는 변수, 함수 선언등의 정보를 담고 있는 전역 객체 또는 활성 객체의 리스트를 말함
  * 식별자의 유효범위를 안에서 바깥으로 차례대로 검색해 나가는 것, outerEnvironmentReference로 가능하게 한다.

</details>

# Rem em 차이
<details>
<summary>답변</summary>

  * 둘 다 font-size를 기준으로 크기가 측정되는 공통점이 있다.
  * font-size의 기준을 무엇으로 하는지가 둘의 차이
    * Rem은 Root, 최상위 요소의 font-size속성에 기준을 둔다. (html 요소)
    * em은 현재 사용되는 곳에서의 font-size속성에 기준을 둔다.
</details>

# 프런트엔드 개발은 지속적으로 학습해야 하는 분야인데 어떤식으로 학습을 하고 있는지?

# 직무 관련 질문

# 프런트엔드 빌드 시스템에 대해서 설명해보세요.
<details>
<summary>답변</summary>

  * Node.js란?
  * NPM이란?
  * ESLint란?
  * Prettier란?
  * 웹 태스크 매니저란?
</details>

# CORS란? CORS를 해결하기 위한 방법을 아는 대로 모두 설명해 주시고 보통 어떤 방식으로 해결하는지 자주 사용하는 방법 1가지와 함께 실제 해결하신 경험을 공유해 주세요.
<details>
<summary>답변</summary>

  * CORS란, Cross Origin Resource Sharing로 출처가(origin) 다른 자원에 접근 권한을 부여하도록 헤더를 통해 브라우저에 알려주는 방식입니다.
    * 예비요청 (preflight Request), 단순 요청 (Simple Request), 인증된 요청 (Credentialed Request) 3가지 방식이 있음.
    * HTML은 Cross-Origin 정책 따름 (link태그의 css 리소스 접근, img 태그 다른 리소스, iframe 등)
    * JS는 SOP 따름 (XMLHttpRequest, Fetch API 등 script태그 내 동일 origin, 다른 도메인은 보안상 제한)
  * CORS 에러 해결방법
    * 응답 헤더에 Access-Control-Allow-Origin에 해당 출처 리소스를 적어서 접근을 허용한다. (express의 res.header에 다른 곳 리소스 적음)
    * Proxy Server를 이용하는 방식 (프록시 서버를 거쳐서 본 서버에 오게 되면, proxy는 동일 출처라서 가능)
    * JSONP방식, SOP (Same Origin Policy) 적용대상에서 제외되는 <script src= "..." >로 추가하는 방법 (예전 방식)
    * Chrome 확장프로그램 이용
  
  * Origin이란, Protocol + Host + Port를 말한다. Origin이 같아야 동일 출처로 인식
    * Protocol: https:// 
    * Host: www.youngun.com
    * Port: 3000, 8080 ....

</details>

# 클로저가 무엇인지 

<details>
<summary>답변</summary>

* 클로저는 함수가 생성될 당시의 외부 변수를 기억하고, 생성 이후에도 외부 변수에 접근할 수 있는 함수를 의미합니다.
* JS에서는 모든 함수가 클로저가 된다.([[Environment]] 프로퍼티로, new Function은 전역으로 설정되어있어서 클로저 불가)
* 함수가 정의될때, Environment 프로퍼티가 생성되고 이 값에 외부 스코프가 저장된다.

```
export function useState<S>(
  initialState: (() => S) | S,
): [S, Dispatch<BasicStateAction<S>>] {
  const dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}

function resolveDispatcher() {
  const dispatcher = ReactCurrentDispatcher.current;
  if (__DEV__) {
    if (dispatcher === null) {
      console.error(
  
      );
    }
  }
  return ((dispatcher: any): Dispatcher);
}

const ReactCurrentDispatcher = {
  /**
   * @internal
   * @type {ReactComponent}
   */
  current: (null: null | Dispatcher),
};

```
* 리액트에서는 useState에서 클로저가 사용된다.
* 전역에 선언된 current에 변수를 담아서, 외부에 선언된 이 값에 접근에서 이전 값을 가져오고, 변경된 상태로 관리한다.
* 함수형 컴포넌트도 동일하게 함수이기때문에, 클로저를 통해서 정의됐을 당시에 접근할 수 있는 외부 상태값에 접근할 수 있다.
꼬리질문⇒ 리액트에서 클로저를 사용하는 부분이 무엇이 있을지 ⇒ useState라고 답했는데 useState함수 내부를 보았는지, 어떻게 구성되어있는지
</details>

# 제너레이터가 무엇인지?

<details>
<summary>답변</summary>

리덕스 사가가 제너레이터함수로 구성되어있다했는데 제너레이터는 무엇인지

* 제너레이터는 코드 블록의 실행을 일시 중지했다가 필요한 시점에 재개할 수 있는 특수한 함수를 말합니다.
  * 제너레이터는 함수 호출자에게 함수 실행의 제어권을 양도할 수 있다.
  * 제너레이터는 함수 호출자와 함수의 상태를 주고받을 수 있다.
  * 제너레이터 함수를 호출하면 제너레이터 객체를 반환한다. (제너레이터 객체는 이터러블이면서 이터레이터)
  * function* 로 정의하고 하나 이상의 yield 표현식을 포함 (*의 위치는 function 키워드와 함수 이름 사이라면 어디든 상관 없음)
</details>

# useState와 useRef의 차이

<details>
<summary>답변</summary>

* useState로 저장된 state값은 state가 변경됨에 따라서 렌더링이 된다.
* useRef는 .current 프로퍼티로 전달된 인자로 초기화된 변경가능한 ref객체를 반환하고, 반환된 객체는 컴포넌트의 전 생애주기를 통해 유지됨. .current값이 변경돼도 re-rendering이 되지 않는다.
  * useRef는 이름을 지어 접근하는 용도나 컴포넌트의 생애주기 내내
* state변경에 따른 re-rendering이 필요할 경우에는 useState를 사용하고 그렇지 않을 경우 useRef를 사용.

* useEffect와 useLayoutEffect의 차이
  * useEffect는 DOM을 그린 이후에 동작
  * useLayoutEffect는 DOM그려지기 전에 동작. 부드러운 사용자 경험 제공가능

</details>

# 리액트에서 리컨실레이션이 무엇인지

<details>
<summary>답변</summary>

* 리액트가 state나 props의 변경될때, 이전에 렌더링된 요소와 새로 렌더링된 요소의 차이를 virtual DOM으로 비교하여 실제 DOM을 업데이트하는 과정을 말한다.
* diffing 알고리즘을 사용해서 두 virtual DOM을 비교한다.
* key값을 index로 하면 성능 저하가 일어나는 이유
  * reconciliation을 할때, 상위부터 내려오면서 비교하게 되는데, 이때, key값을 index로 하면 순서가 바뀌어서 두 차이를 확인할 때 비효율이 생긴다.
  * key를 통해서 기존 트리와 변경 트리를 확인하기 떄문에.

</details>

# 웹팩이란? 모듈 번들러가 무엇인가요?

<details>
<summary>답변</summary>

  * 웹팩은 여러개로 나누어진 파일을 하나의 자바스크립트 코드로 압축하고 최적화해주는 가장 많이 사용되는 모듈 번들러 라이브러리 입니다.
  * 파일이 여러개 나누어지면, 웹페이지에서 나타낼때, 파일을 받기위해 여러번 통신해야되는 비용을 줄일 수 있습니다.
  * 여러 JS파일을 하나의 파일로 묶어서 한번에 가져올 수 있게 해주고, 최신 문법을 브라우저에서 쓸수 있게 해줍니다.
  * 즉시 실행함수를 통해서 클로저를 생성시켜, 스코프를 만든다. 변수 분리

  * module이란?
    * 모듈은 재사용가능한 코드 조각들이다. 쉽게 이야기하면 .js파일
    * 모듈은 자신만의 스코프를 가지고(모듈 스코프), export, import 가능
    * 일반적으로 하나의 클래스나 특정 목적을 가진 복수 함수로 구성된 라이브러리이다.
  * bundler란?
    * 번들러는 css, js, 이미지 등의 파일을 묶어주는 것을 번들링이라고 하는데, 그 결과물을 번들이라 한다.
    * 그 일을 해주는 것을 번들러라고 한다.

</details>

# Virtual DOM이 뭔지 아시는지? 썼을 때의 장점?
  * (꼬리 질문) 브라우저 동작 원리 아는 만큼 설명

<details>
<summary>답변</summary>

  * virtudal DOM이란, React Reconciliation과정에서 효율적으로 변경된 부분을 확인하기 위해서 사용하는 DOM을 추상화한 가상 객체입니다.
  * 실제 DOM을 조작하여 렌더링이 자주 생기는 것보다 메모리상의 객체로 관리하는 virtual DOM을 사용해서 변경된 부분을 수정하고 그 부분만 실제 DOM에 적용시켜 한번만 렌더링시킵니다.

  * 브라우저 동작원리
    * HTML과 CSS를 파싱해서 DOM 트리와 CSSOM 트리로 변환시켜 둘을 합쳐서 렌더트리로 결합한다.
    * 렌더 트리를 기준으로 레이아웃 배치(리플로우)와 페인트 작업이 진행후 나타냅니다.

</details>

# 서버 사이드 렌더링과 싱글 페이지 애플리케이션의 차이점?
  * (꼬리 질문) 서버 사이드 렌더링이나 SPA로 각각 구현해 본 경험이 있는지?

<details>
<summary>답변</summary>

  * 서버 사이드 렌더링은 서버에서 즉시 렌더링 가능한 html파일을 만들어서 클라이언트에 전달되는 순간, 즉시 렌더링된다. (viewable)
    * 클라이언트에서 그 이후에 js파일을 다운받고, 다운 받아진 이후에 상호작용 가능해짐
    * SEO에 유리, 빠른 초기 로딩이 장점이지만, UX좋지 않음(화면 깜빡임)과 서버 부하가 있다는 단점
    * 주로 MPA(Multi Page Application)에서 사용
  * SPA는 인터랙션이 발생할 때마다 서버로부터 새로운 파일을 받아 해당 링크로 이동하여 페이지 전체를 새로 렌더링하는 전통적인 웹페이지 구성방식
    * 주로 CSR(Client Side Rendering)을 사용해서 구현한다.

</details>

# 웹 접근성과 시맨틱 마크업이란? 이 2가지를 지키기 위해 보통 어떤식으로 마크업을 작성하는지?

<details>
<summary>답변</summary>

  * 시맨틱 마크업이란 html 각 태그를 의미론적으로 적절하게 용도에 맞게 사용하는 것을 말합니다. 
  * header와 footer, main과 section, 독립적 컨텐츠에 article, 최상위 제목에 h1, 순서 목록 ul, li 내비게이션 nav
  * 이외도 strong과 b태그 중 태그 자체가 가지는 의미로 strong이 시맨틱 마크업에 적합하다.

  * 검색엔진이 시맨틱 마크업을 중요한 키워드로 간주하기 때문에, 검색엔진 최적화에 유리하다.
  * 뿐만아니라 시각에 불편함이 있는 분들에게또한 웹 접근성 측면에서도 좋다.
  * 가독성이 좋아 유지보수에 편리하다.

  * 웹 접근성이란, 장애를 가진 사람이나 갖지 않은 사람 모두가 웹사이트를 이용하게 하는 방식을 말합니다. 
  * 사이트가 올바르게 설계되고 개발되어야 모두가 동등하게 서비스를 이용할 수 있습니다.

  * meta tag란?
    * 해당 문서에 대한 메타 데이터를 정의할 때 사용하는 태그입니다.
    * 메타 태그로 제공된 정보는 브라우저 검색엔진이나 다른 웹서비스에서 사용하게 됩니다.
    * charset, content, http-equiv, name, scheme의 속성을 가지고 있습니다.
</details>

# 웹 서비스 배포 시스템 구축 경험?
  * (꼬리 질문) CI, CD가 무엇인지 아는지? 구축해본 경험 혹은 사용해본 경험이 있는지

<details>
<summary>답변</summary>

  * CI, CD는 애플리케이션 개발단계를 자동화하여 애플리케이션을 보다 짧은 주기로 고객에게 제공하는 방법을 말합니다.
  * CI는 Continuous Integration로, 개발자를 위한 자동화 프로세스를 말합니다.
  * CI가 성공적으로 구현될 경우, 애플리케이션의 새로운 변경사항이 정기적으로 빌드 및 테스트되어 공유 레포지터리에 통합됩니다. 협업시에 코드가 충돌할 상황을 예방해준다.
  * CD는 Continuous Deployment는 개발자의 변경사항을 리포지터리부터 유저의 프로덕트 환경까지 자동으로 릴리즈하는 것을 말합니다. 파이프라인 다음 단계를 자동화
  * 애플리케이션 제공속도를 저해하는 수동 프로세스에 대한 리소스를 줄일 수 있다.

</details>

# 백엔드 개발 경험이 있는가?
  * (꼬리 질문) REST API 구축 경험과 구현 관점에서의 간단한 REST API 설계 방식 설명해 보세요. 브라우저의 URL 요청을 받아서 서버의 데이터를 화면에 다시 뿌려주기까지의 백엔드 쪽의 플로우를 알고 있는지 확인하는 차원.

<details>
<summary>답변</summary>

  * REST 아키텍쳐 스타일 원칙
    * Uniform Interface - Http 표준만 맞다면 어떤 기술도 가능한 interface 스타일로, API 메세지만 보고도 API를 이해할 수 있는 구조
    * Stateless - 클라이언트와 서버 서로가 서로의 상태(정보)를 가지고 있지 않음
    * Layered System - 서버가 다중 계층으로 구성되어 API Server는 순수 비즈니스 로직을 수행하고 보안, 로드밸런싱, 암호화, 사용자인증 등 추가하여 구조상의 유연성을 줄 수 있다.
    * Cacheable - 웹 서버의 응답 시간을 개선하기 위해 클라이언트에 응답을 저장하는 프로세스인 캐싱을 지원함
    * code on demand - Server로 부터 script(프로그래밍 코드)를 받아서 Client에서 수행할 수 있다.
    * Resource 지향 아키텍쳐 - 복수형의 명사로 나타냄
  * RESTful API를 사용하면 확장성, 유연성, 독립성의 장점을 가지게 된다.
  * 로드밸런싱이란, 컴퓨터 네트워크 기술의 일종으로 둘 혹은 셋이상의 중앙처리장치 혹은 저장장치와 같은 컴퓨터 자원들에게 작업을 나누는 것을 의미합니다. 즉 여러 서버가 분산처리하는 것을 말한다.
    * L4 transport계층을 사용해서 IP 주소와 포트 번호 부하 분산 가능
    * L7 application계층을 사용해서 URL 또는 HTTP 헤더에서 부하 분산 가능

  * PUT과 POST의 차이
    * idempotence(멱등성)으로 PUT은 멱등성을 갖지만, POST는 갖지않는다.
    * 멱등성이란 동일한 값을 넣었을 때, 같은 결과값을 내는 것을 말한다.
    * PUT은 update, POST는 create이다.

  * PUT과 PATCH의 차이
    * PATCH는 일부만 수정할때 사용하고, PUT은 전체를 수정할 때 사용한다.

</details>


# 자바스크립트 프레임워크를 써봤는지? 써봤다면 어떤 걸 쓰는지? 만약 쓴다면 쓰는 이유와 썼을 때의 장점?
# “기획 - 디자인 - API 개발 - 프런트엔드 개발”의 서비스 절차에서 프런트엔드 개발자의 역할은 무엇이라고 생각하는지?
# 프런트엔드 성능 최적화란? 프런트엔드 성능 최적화 경험이 있다면 자세하게 설명해달라.


# 테스트 자동화 경험? 단위 테스트 또는 E2E 코드를 작성해 본적이 있는지?
  * (꼬리 질문) 테스팅 라이브러리와 프레임워크에 특화된 테스팅 라이브러리는 각각 어떤 걸 썼는지?
  * (꼬리 질문) 테스트 대상과 커버리지는 보통 어떻게 잡는지?
# 웹 서비스를 기획부터 배포까지 모두 스스로 해본 경험이 있는가? 토이 프로젝트나 회사 서비스 등
  * (꼬리 질문) 구체적으로 어떤 역할을 수행했는지 설명
# SEO(검색 엔진 최적화)란? 적용 사례가 있으면 구체적인 적용 방법도 같이 설명
# REST API로 받은 객체와 배열은 보통 어떤 자바스크립트 API나 로직을 이용해서 화면에 맞게 가공을 하는지?
  * (꼬리 질문) map, filter, reduce API 사용 경험과 각각 설명
# 함수형 프로그래밍이란?
  * (꼬리 질문) 자바스크립트 클로저란?
  * (꼬리 질문) 자바스크립트 프로토타입이란?

# 나올 수 있는 질문

# 타입 시스템에 대해서 알고 있는지? 타입스크립트를 써봤는지?
  * (꼬리 질문) 자바스크립트와 타입스크립트의 차이점?
  * (꼬리 질문) 타입스크립트의 장점과 단점?
# 웹 서비스의 사용성을 개선하기 위해 고민해 봤던 부분이 있는지? 구체적인 사례와 경험 설명
# 자바스크립트 관련해서 모르는 문법이나 API가 나왔을 때 관련 정보를 어떻게 검색하는지?
# 다른 직무의 동료들과 어떤 식으로 커뮤니케이션 하는지?
# 여태까지 소속되었던 팀 내부적으로 혹은 회사 외부적으로 지식 공유나 지식 전파 같은 활동들을 해본 적이 있는지?
# 새로 배우는 개발 지식은 보통 어떤 식으로 정리하는가?
# 코딩 컨벤션은 보통 어떤 걸 따르고 코딩 컨벤션을 프로젝트에 적용하기 위해 어떤 노력들을 하는지?

# 그 외 기본적 질문

# 이 직무로 지원한 이유?
# 이 직무로 지원했을 때 하는 일에 대해서 얼마나 조사 및 이해를 하고 왔는지?
# 이직하려는 회사의 직무에서 기대하는 부분과 기여할 수 있는 부분?


리덕스가 무엇인지 ⇒ 전역 상태 관리를 하는 다른 것을 써보았는지 ⇒ context API라고 답했는데 다음에 사용한다면 리덕스와 contextAPI중 어떤 것을 사용할것인지
웹팩과 바벨이 무엇인지 ⇒ 웹팩을 사용했을 때 이점
브라우저에 url을 쳤을 때, 일어나는 일련의 과정을 아는대로 설명
드래그앤드롭을 어떻게 구현하였는가
CSS관련 질문
Styled 컴포넌트를 사용한 이유 ⇒ 사용해봤을 때, 일반 css파일로 사용한 것과 어떤 차이점을 느꼈나
CSS를 하면서 어려웠던 것이 있나 ⇒ flex와 grid라 했는데 그 둘의 차이는 무엇인가
가운데 정렬 하는 법은 무엇이 있는가
vh, vw가 무엇인가


<details>
<summary>답변</summary>

</details>

### 기술 질문

- 이벤트 위임 (event delegation)
- CSS inline, block, inline-block 의 차이점
  * display inline은 마크업하고 있는 컨텐트 크기만큼 공간만 차지하고, width와 height를 조정은 무시되고, margin과 padding을 좌우만 반영됩니다. 다른 엘리먼트들과 같은 줄에 위치할 수 있습니다. span, a 태그를 예로 들 수 있습니다.
  * 반면에 block으로 지정된 엘리먼트는 한줄을 차지하고, width, height, margin, padding 속성을 모두 반영할 수 있습니다. div, p, h1태그를 예로 들 수 있습니다.
  * inline-block는 inline과 block 디스플레이의 속성을 가지고 있습니다. 기본적으로는 다른 엘리먼트들과 나란히 배치되지만, width, height, margin, padding을 조절할 수 있습니다.
- 시멘틱 마크업
  * 시맨틱 마크업이란 html 각 태그를 의미론적으로 적절하게 용도에 맞게 사용하는 것을 말합니다. 
- garbage collection
  * JS가 할당된 메모리가 더 이상 필요없을 때, GC를 통해 판단하고, 회수합니다.
- RDB
  * Relation Data Base란 관계형 데이터 모델에 베이스를 둔 데이터베이스를 말합니다. 모든 데이터를 2차원 테이블 형태로 표현해줍니다.
- 자료구조(해시테이블)
  * key값에 해시 함수를 적용해서 변환한 값을 index로 배열에 value를 저장하는 자료구조를 말합니다.
  * 평균 시간복잡도가 O(1)로 빠르게 데이터를 검색할 수 있는 자료구조이다.
- 바이너리 서치 트리(이진 탐색 트리)
  * 이진 탐색 트리는 이진탐색과 연결리스트를 결합한 구조입니다. 
  * 이진 탐색의 효율적인 탐색 속도 O(logN)와 연결리스트의 빠른 자료 입력 삭제 O(1)의 장점을 결합한 것입니다. 
  * 노드의 왼쪽 서브 트리는 해당 노드 값보다 항상 작습니다.
  * 노드의 오른쪽 서브 트리는 해당 노드 값보다 항상 큽니다.
- 정렬
- This
  * 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수를 말합니다.
  * 호출 방식에 방식에 따라서 4가지로 분류될 수 있습니다.
- call, apply, bind
- async await와 promise
- MVC, MVVC
  * Model, View, Controller로 관심사를 나눠서 비즈니스 로직과 화면을 구분하는데 중점을 둔 소프트웨어 디자인 패턴입니다.
    * 비즈니스 로직과 UI로직을 분리하여 유지보수 독립적으로 가능
    * Model, View가 다른 컴포넌트에 종속되지 않아서 어플리케이션 확장 쉬움
    * 하나의 Controller에 다수의 Model과 View가 복잡하게 연결될 수 있음
  * Model, View, ViewController로 관심사를 나눈 MVC에 기반을 둔 디자인 패턴입니다.
  * Model은 데이터와 비즈니스 로직 관리
  * View는 레이아웃 화면 처리
  * Controller는 명령을 Model과 View 부분으로 라우팅합니다.
- call by reference, call by value
  * js는 기본적으로 call by value방식으로 함수 실행시 arguments를 복사된 값으로 넘어와서 callee에서 어떤 연산을 해도 원본 값은 영향받지 않는다.
  * call by reference는 함수 실행시 reference값을 arguments로 넘기므로 함수에서 동작시 원본이 영향을 받는다.
    * js에서는 call by value이므로 reference값 또한 참조 값에 대한 복사본을 넘긴다.
  * 참조값에 대한 혼란을 줄이고자 call by sharing이라 부르기도 한다.
- primitive 타입과 object의 차이점, 특징
  * primitive 타입은 데이터 복사가 일어날 때, 메모리 공간을 새로 확보하여 독립적인 값을 저장
  * object, 참조 타입은 메모리의 직접 접근이 아닌, 메모리의 위치(주소)에 대한 간접적인 참조를 통해 접근
    * 참조 타입은 변수의 크기가 동적으로 변하기 때문에, 별도의 메모리 Heap에 저장되고, 변수에 할당 시 Heap 메모리 주소 값이 저장
- 실행컨텍스트와 렉시컬 환경
  * 실행컨테스트는 JS 소스코드를 평가하고, 소스코드가 실행하는데 필요한 환경정보를 모아놓은 객체입니다.
    * 실행컨텍스트객체가 활성화되는 시점에서 variable environment(최초 스냅샷), lexical environment(실시간), thisvalue 정보를 수집합니다. (활성화 되는것은 실행컨텍스트 스택 최상단에 위치할때)
  * 실행컨텍스트 내부에는 식별자에 대한 정보(environmentRecord)와 외부 스코프에 대한 정보(outerEnvironmentReference)를 가지고 있는 렉시컬 환경이 있습니다.
- 호이스팅
  * 식별자들을 최상단으로 끌어올리는 행위를 말합니다.
  * var는 변수 선언과 초기화를 동시에 진행되지만, let과 const는 선언만 이루어진다.
- 클로저
- 스코프
  * 식별자에 대한 유효범위를 말합니다.
- TDZ
  * Temporary Dead Zone으로 let과 const는 호이스팅에의해서 변수 선언이되고 초기화가 되기 전까지 해당 변수를 호출하면 Reference error가 생긴다. const, let, class에 영향을 준다.
- 1급 객체의 조건
  * 변수에 담을 수 있다.
  * 매개변수에 넘길 수 있다. 
  * 함수에서 반환할 수 있다.
- 브라우저의 랜더링 원리
- repaint과 reflow의 차이점
  * reflow는 레이아웃이 변경되면 노드의 위치나 크기를 계산해서 다시 레이아웃을 잡는 것이고, repaint는 레이아웃 과정 수행이후에 계산된 요소들, 위치와 크기, 스타일들을 다시 그리는 행위입니다.
- local storage, session storage, cookie. 로그인 외에 어떤 경우에 쓸수있는지, 장단점 등.
  * local storage는 시간제한이 없고, 브라우저가 닫혀도 계속 존재한다. (직접 지워야함) 10mb
  * session storage는 세션의 종료시 즉시 삭제됨, 세션은 일반적으로 브라우저의 종료를 의미한다. 탭단위의 브라우저 5mb
    * 웹스토리지 객체는 네트워크 요청시 서버로 전송되지 않아서, 더 많은 자료 보관가능
  * 쿠키는 html5이전에 사용했던 key value 저장방식으로, 서버와 클라이언트 양쪽에서 쿠키 데이터를 사용하는 api가 존재한다. 기간이 존재한다. 4kb, 문자열만 저장가능
    * 이러한 이유로 서버쪽에서의 사용이 잦고 필수적이라면 양쪽에서의 인터랙션이 효과적인 쿠키값을 사용하는 것이 좋다.
- Event loop와 js 실행 순서
  * 일반적인 함수들은 js엔진의 콜스택에 추가되어서 실행되고, event loop가 콜스택이 비어져있는 지를 확인하면서, 마이크로 태스크 큐와 태스크 큐에 있는 비동기 함수를 콜스택으로 이동시켜서 함수를 실행시킨다.
- var let const 차이점
- cors의 정의와 생긴 이유, 어떻게 우회하는지
- Restful api를 왜 써야하는지 (Update 기능을 왜 Delete 메소드로 하면 안되는지)
  * URI는 정보의 자원을 표현하고 HTTP메소드는 자원의 행위를 표현하는 방식입니다.
  * REST의 설계규칙을 잘따라서 만들면 api 주소만으로도 어떤 것을 요청하는 지 파악하기 가능합니다.
  * update기능은 http 메소드의 post를 사용하는게 적절하기 때문입니다. (아니면 RESTful 깨짐)
- http와 https의 차이. 장단점
  * http에 데이터 암호화가 추가된 프로토콜이다. 
  * 보안상 우위가 있고 SEO에 혜택을 볼 수 있다.
  * 암호화/복호화 과정으로 http 보다 느리고 (요즘은 거의 차이없음), 인증서 발급, 유지를 위한 추가비용
  * SSL(Secure Socket Layer)을 쓰냐 안쓰냐의 차이가 있다.
  * 문서 전송시 암호화처리 유무에 따라서 HTTP, HTTPS로 나뉨
  * TCP => HTTP (HTTP), TCP => SSL => HTTP (HTTPS)
- 바벨
- 웹팩
- 같은 크기의 웹팩으로 압축한 프로젝트와 웹팩으로 압축하지 않은 프로젝트가 있을 때 무엇이 더 좋을까(빠를까), 그 이유는?
- 더블 이퀄 & 트리플이퀄
  * 더블 이퀄은 자동 형 변환을 사용해서 값만 비교하는 오퍼레이터로 타입이 달라도 같은 값을 나타내면 true를 나타낸다. 12 == "12" true
  * 트리플 이퀄은 자동형 변환을 사용하지 않고 strict하게  값과 타입 모두 비교하는 오퍼레이터이다.
- 커링
  * 함수가 n개의 인자를 받는 과정을 n개의 함수로 각각 인자를 받도록 하는 것을 말합니다. 
  * 함수형 프로그래밍의 이유와 같이 side effect를 최대한 줄이고 가독성과 유지보수를 높히기 위해서 입니다. 
- 재귀 써본적 있는지
- js와 jsx의 차이
  * jsx는 js에 xml을 추가한 확장형 문법으로, JS로 HTML 문법을 사용할 수 있습니다.
  * js코드안에서 UI 관련 작업을 할 때, 시각적으로 도움을 줄 수 있습니다.
- CDN
  * 컨텐츠 전송 네트워크는 지리적으로 분산된 여러 개의 서버로서 웹 콘텐츠를 사용자와 가까운 곳에 전송함으로 전송속도를 높입니다.
- ES6(2015)를 지원하지 않는 곳에서 자바스크립트를 써야한다면?
- 타입스크립트와 자바스크립트의 차이점
- 얕은 복사 깊은 복사
  * 얕은 복사는 객체의 참조 값을 복사하고, 깊은 복사는 객체의 실제 값을 복사합니다.
- ECMAScript와 JavaScript의 차이점은 무엇인가요?
  * ECMA international에 의해 제정된 ECMA-262 기술 규격에 의해 정의된 범용 스크립트 언어입니다.
  * JS는 ECMAScript의 사양을 준수하는 범용 스크립팅 언어입니다.
- 자바스크립트의 데이터 타입을 모두 나열해 주세요.
- 객체의 프로토타입에 대해 설명해 주세요.
  * 객체 간 상속을 구현하기 위해 JS에서 사용되는 개념입니다.
  * 상위 객체가 갖고 있는 속성과 메서드들은 객체 생성자의 프로퍼티를 속성에 정의되어 있는데 이를 상속받은 하위 객체는 자신의 프로퍼티처럼 자유롭게 사용할 수 있습니다.

- 리액트에서 랜더링 과정
  * 리액트에서 렌더링은 컴포넌트가 props와 state 상태에 기초하여 UI 구성에 대해 컴포넌트에 요청하는 작업을 의미합니다.
  * 렌더링이 시작되면 컴포넌트의 루트부터 시작해서 쭉 하위요소로 보면서 업데이트가 필요한 컴포넌트를 찾아서, 클래스 컴포넌트일 경우에는 classComponentInstance.render()를, 함수형 컴포넌트일 경우에는 FunctionComponent()를 호출하고 렌더링된 결과를 저장합니다.
- 리액트는 어떻게 변화를 감지하는지
  * virtual DOM의 비교를 통해서 변화를 감지한다.
- 훅이란? 훅을 사용하는 이유
  * 기존의 class를 바탕의 코드작성할 필요없이 상태값과 여러 React기능을 사용할 수 있도록 만든 기능입니다.
  * hook은 컴포넌트들 사이에 상태 로직 재사용, 복잡한 컴포넌트들 이해하기 어려움, 클래스에 대한 어려움때문에 만들었다.
- 써본 훅이 있는지? 그건 어떤 훅이고 어떻게 작동하는지? (훅 두세개의 작동원리 정도는 알고 가는 것 추천)
  * useState, state값을 저장하고, 변경하는 함수를 가지고 있습니다. 
  * useEffect, side effect를 발생시키는 훅으로 DOM이 다 그려지고 난 이후에 dependency의 값에 따라서 실행된다.
  * useRef .current 프로퍼티로 전달된 인자로 초기화된 변경가능한 ref 객체를 반환, 전 생애주기 동안 유지된다.
  * useLayoutEffect, DOM을 그리기 이전에 실행되는 훅
- 제일 좋아하는 리액트 관련 라이브러리는?
- 제일 좋아하는 (많이 써본) 훅은? 그 훅에 대한 설명.
- 컴포넌트의 생명주기
  * 클래스 기반 컴포넌트를 기준
  * Mount시에 constructor, getDerivedStateFromProps, render, componentDidMount
    * getDerivedStateFromProps는 props로 받은 걸 state로 넣어주고 싶을 때
  * Update시에는 getDerivedStateFromProps, shouldComponentUpdate, render, getSnapshotBeforeUpdate, componentDidUpdate
    * getSnapshotBeforeUpdate 컴포넌트가 변화가 일어나기 직전의 DOM상태를 가져와서 조건을 설정하고 특정값을 반환하면, 그 값을 componentDidUpdate에서 받아와서 사용가능하다.
  * UnMount시에 componentWillUnmount
  * 클래스형 컴포넌트에서 주로 사용하지만, useEffect내에서 각각 componentDidMount, componentDidUpdate, componentWillUnmount정도로 나눠서 구현할 수 있을 것 같다.
- useMemo와 React.memo의 비교
  * React.memo는 HOC이라 클래스형 함수형 컴포넌트 모두 사용가능, useMemo는 hook이라서 함수형 컴포넌트에서만 사용가능하다.
  * 공통점은 둘다 props가 변하지 않으면 인자로 넘긴 함수가 실행되지 않고, 이전에 저장된 결과값을 넘긴다.
  * React.memo의 두번째 인자로 받은 props를 비교할 수 있는 함수를 넣을 수 있다. (기본 얕은 비교)
- redux를 사용하는 이유
- 리덕스를 사용했을 경우, 실제로는 state가 어디에 저장되는지
- 디핑 알고리즘
- 고차 컴포넌트 (hoc)
- state를 왜 직접 수정하면 안되는지
  * state는 불변성을 유지해야하는데, 컴포넌트는 현재의 state와 setState로 받은 인자인 새로운 state와 비교해서 필요시 render함수를 호출하는데, state를 직접 변경하게 되면 render함수를 호출하지 않아서 상태가 변경되도 rendering이 되지않는다.
  * state를 직접 변경하면 state가 React 컴포넌트가 변경된 것을 인지하지 못하고 re-rendering이 일어나지 않습니다. (setState를 사용한 후에 render함수가 실행됨)
- 리액트의 단점이 무엇이라고 생각하는지
  * life cycle에 대한 적절한 이해없거나 state나 props의 변경에 따른 rendering을 제대로 고려하지 않으면 원치 않은 rendering이 생길 수 있다.
  * view만 관리해서 그 이외의 데이터 모델링은 서드파티 라이브러리를 사용해야 한다.
  * 앱의 규모가 커지면 무거워져 느려진다.
- 클래스형으로 쓰는 것과 함수형으로 쓰는 것의 차이점
  * 클래스형 컴포넌트에서는 생명주기 메서드 함수를 사용할 수 있다. 
  * 함수형 컴포넌트에서는 useEffect 훅을 이용해서, 어느정도 사용할 수 있지만, 클래스형만큼 명확하지 않고 존재하지 않는 메서드들이 있다.
  * 함수형은 선언하기 더 편하고, 메모리 사용을 덜 한다는 장점이 있다.
- 왜 CRA를 사용해야하는가?
- Falsy로 평가되는 값은 무엇인가요?
- 리액트 훅에 대해 설명해 주세요.
- Event Loop에 대해 설명해 주세요.

- 일반 함수와 화살표 함수의 차이점은 무엇인가요?
  * this, 생성자 함수로 사용여부(prototype을 갖지 않음), arguments존재 여부
- DOM과 VirtualDOM은 각각 무엇이고, VirtualDOM의 이점은 무엇인가요?
- ES6에서 추가된 문법을 아는대로 설명해 주세요.
  * const, let, class, Promise, 화살표 함수, 객체 리터럴 강화, 매개변수 기본값 지정 가능, 구조 분해 할당, Spread, Rest, 템플릿 리터럴, 모듈
- `==` 연산자와 `===` 연산자의 차이점을 설명해 주세요.
- 리덕스가 무엇이고, 사용했을 때의 이점은 무엇인가요?
- Hash Table에 대해 설명해 주세요.
- OOP에 대해 아는대로 설명해 주세요.
  - `class`, `private`, `public`
  - `private` 키워드를 사용하지 못 한다면 어떻게 캡슐화를 할 수 있을까요?
  * 프로그램 설계방법론이자 개념의 일종으로, 프로그램을 수많은 객체라는 기본단위로 나누고 이들의 상호작용을 나타내는 방식을 말합니다. 여기서 객체는 하나의 역할을 수행하는 메소드와 변수의 묶음으로 볼 수 있습니다.
  * OOP은 캡슐화, 추상화, 상속, 다형성(polymorphism)의 요소를 가집니다.
  * JS 기본 class의 속성들은 public이지만, #를 추가해서 private으로 설정할 수 있습니다.
    * public은 class 외부에서 읽고 수정할 수 있지만, private은 해당 class에서만 가능하다.
  * private이 존재하지 않을땐, 클로저를 사용해서 구현, 코딩 컨벤션으로 private으로 약속하기도...(_)
  * es6에 도입된 class 문법은 private, public 필드와 getter, setter 메서드등을 사용해서 OOP를 구현을 편리를 주는 문법적 설탕이다.
- 모듈 패턴에 대해 설명해 주세요.
  * 모듈은 전체 어플리케이션의 일부를 독립된 코드로 분리해 놓은 것을 의미하는데, 특정 구성요소를 다른 구성요소와 독립적으로 유지하는 패턴을 말합니다.
- 팩토리 패턴에 대해 설명해 주세요.
  * 팩토리 패턴은 객체를 생성하는 인터페이스는 미리 생성해두고, 인스턴스를 만들 클래스의 결정은 서브 클래스쪽에서 내리는 패턴
  * 여러개의 서브클래스를 가진 슈퍼 클래스가 인풋에 따라서 하나의 자식클래스의 인스턴스를 리턴해주는 방식입니다.
- 리액트를 사용하는 이유가 무엇이라고 생각하시나요?
  * 복잡하고 동적인 SPA을 만들기 위해서, 리액트인 이유는 우선 커뮤니티가 가장 크기 때문에 정보를 쉽게 얻을 수 있고, 다양한 플러그인 지원, 업데이트를 잘해준다는 장점이 있습니다.
- JsonWebToken에 대해 설명해 주세요.
  * JWT은 유저를 인증하는 방식 중 하나로, 인증에 필요한 Token을 암호화 해서 인증된 유저에게 제공하고, 유저가 클라이언트에 가지고 있다가, 서버에 데이터를 요청을 할때, 헤더에 실어서 함께 보내면, (header, payload, signature)로 구분되어 암호화된 token을 디코딩해서 유저를 인증할 수 있습니다.
  * 세션과 다르게 stateless하여 확장성이 뛰어나고 signature를 통해서 보안성도 갖추고 있습니다. 
- MongoDB를 사용한 이유가 무엇인가요?
- 정렬 알고리즘 중 가장 빠른 것은 무엇인가요?
  * 퀵 소트입니다. 평균 O(NlogN), 최악의 경우 O(N^2)입니다.
  * 피벗을 활용하여 재귀를 이용해서 정렬을 합니다.
  * 추가적인 메모리 공간을 필요로 하지 않습니다.
- 클래스형 컴포넌트와 함수형 컴포넌트의 차이는 무엇인가요?
  * 클래스형 컴포넌트는 라이프 사이클 메소드를 가지고 있어서, 좀 더 명확하고 세분화해서 mount, update, unmount 각각의 상황에 맞는 method를 사용할 수 있습니다. 메모리 자원을 더 사용함
  * 함수형 컴포넌트는 Hook을 사용하는 대표적인 특징이 있고, 기존에 클래스형 컴포넌트에서 구현했던 것들을 Hook을 대부분 대체할 수 있습니다. 
- 생명주기에 대해 설명해 주세요.
  * mount, 컴포넌트가 처음 실행될 때를 의미하고, 이때 constructor, getDerivedStateFromProps, render, componentDidMount가 순서대로 호출됩니다.
  * update, props나 state가 변경될때이고, getDerivedStateFromProps, shouldComponentUpdate, render, getSnapshotBeforeUpdate, ComponentDidUpdate가 순서대로 호출됩니다.
  * unmount, 컴포넌트가 DOM에서 제거될때 이고, componentWillUnmount가 호출됩니다.
  * 오류처리시에는, getDerivedStateFromError, componentDidCatch가 호출됩니다.
- Box Model에 대해 설명해 주세요.
  - 컨텐츠 박스를 변경하는 속성(box-sizing)에 대해서 알고 있는지와 그에 대한 설명
  * HTML element가 웹페이지에서 차지하고 있는 공간을 정의한 모델을 의미합니다.
  * element가 담긴 content, element를 감싸는 border, border와 content사이 padding, border의 바깥부분 margin으로 구성됩니다.
  * box-sizing은 content-box와 border-box로 속성을 변경할 수 있습니다.
    * content-box는 기본 css 박스 크기 결정법으로 컨텐츠 영역이 width를 가지고, 이에 border와 padding이 더해집니다.
    * border-box는 컨텐츠 영역뿐만아니라 border와 padding또한 요소의 크기로 정해집니다. 이 방식이 크기 조절하기 용이합니다.
- Position 속성에 대해 설명해 주세요.
  * position 속성에는 static, relative, absolute, fixed, sticky가 있습니다.
    * static은 요소를 문서의 흐름에 따라 배치하고 속성들(top, left, z-index...)이 영향을 주지 못합니다.
    * relative는 요소를 문서흐름에 배치하고 자기 자신을 기준으로 속성들이 적용되도록 합니다. 
    * absolute는 일반적인 문서흐름을 제거하고, 페이지 레이아웃 공간 배정하지 않습니다. 상위요소의 relative를 기준으로 속성들이 적용됩니다.
    * fixed는 일반적인 문서흐름은 제거하고, 페이지 레이아웃 공간 배정하지 않습니다. 뷰포트의 초기 컨테이닝 블록을 기준 삼아 배치합니다.
    * sticky는 일반적인 문서흐름에 배치하고, 테이블관련 요소를 포함해 가장 가까운 스크롤되는 조상과 표관련 요소를 포함하는 컨테이닝 블록을 기준 삼아 오프셋 적용하고, 스크롤동작이 가능한 가까운 조상요소에 붙게 됩니다.
    * 일반적으로는 컨테이닝 블록은 가장 가까운 블록레벨 조상의 컨텐츠 영역입니다. (padding, margin등으로 변경되기도 함)
- z-index가 무엇인가요?
  * 위치 지정 요소와 그 자손 또는 하위 flex item의 z축의 순서를 지정합니다.
  * 큰 값을 가질수록 앞쪽에 존재하게 됩니다.
- CSS sprite란 무엇인지?
  * 서버에 요청을 줄여서 성능을 개선하는 방법으로 사용하는 여러개의 image들을 합쳐서 하나로 관리하는 방법을 의미합니다.
  * background-image와 background-position을 이용하여 사용하는 방법을 의미합니다.
- flex, grid
  * flex는 1차원의 레이아웃을 만들때 사용합니다. (컨테이너내부에 아이템이 위치)
    * main axis기준, 수평 방향 정렬은 justify-contents, 수직 방향 정렬은 align-items
  * grid는 2차원의 행과 열 두 축으로 flex보다 복잡한 레이아웃을 만들때 사용합니다.
- 동기 프로그래밍과 비동기 프로그래밍의 차이점을 설명해 주세요.
  - Promise, Async / Await
- 클로저에 대해 아는대로 설명해 주세요.
- CSS와 CSS in JS에 대해 설명해 주세요. 
  * CSS in JS는 js 코드에서 css를 작성하는 방식을 말합니다. 대표적으로 styled component, emotion이 있습니다.
  * 효율적이고 파일을 따로 관리하지 않아도 된다는 점과 동적 css관리 장점이 있지만, 기존 방식보다는 느리다는 단점이 있습니다. 
- 쿠키에 대해 설명해 주세요.
  * html5 이전부터 사용한 브라우저 저장방식으로 4kb의 string으로 만료기한이 있고 브라우저에 저장할 수 있습니다. 
  * 세션 쿠키와 지속쿠키가 있고, 만료기한을 지정하지 않으면 세션쿠키, 지정하면 지속 쿠키입니다.
  * 세션 쿠키는 브라우저가 종료와 같은 세션이 종료되면 사라지고, 지속 쿠키는 만료 기한때 제거됩니다.
- Local Storage를 사용할 때의 장 / 단점에 대해 설명해 주세요.
  * key-value 형식으로 저장 가능, 비교적 큰 용량 저장, 서버에 불필요하게 데이터 저장 안함
  * html5 지원하지 않는 브라우저에서 사용 불가
- 디렉토리 구조에 대해 고민했던 경험이 있나요?
- 컴포넌트를 재사용했던 경험이 있나요?
  - 컴포넌트를 재사용할 때 겪었던 문제점은 무엇인가요?
- 디자인 시스템에 대해 아는대로 설명해 주세요.
- 기억에 남는 상태 관리 경험에 대해 설명해 주세요.
- TDD(Test-Driven-Development)와 DDD(Domain-Driven-Development)에 대해서 아는지?
  * 테스트 기반 개발방식을 의미하고, 테스트 코드를 우선 작성하고, 테스트를 통과할 수 있는 최소 코드를 작성하며 개발하는 방법을 말합니다.
  * 비즈니스 도메인 별로 나누어 설계하는 방식을 말합니다. 
    * 모듈간 의존성은 최소화하면서, 응집성은 최대화하는 것이 목표입니다. ("Loosly coupling", "High cohesion")
- (url에 주소 입력하는 시점부터) 브라우저 렌더링 과정
- 이벤트 위임(버블링, 캡쳐링의 차이)이 무엇인지, 적용 경험이 있는지, 왜 적용했는지
- 함수를 선언할 때 표현식, 선언식 중에 무엇을 선호하는지? 그 이유는?
- null, undefined란 무엇이고 어떻게 구분하는지?
- 스코프, 호이스팅, var let const, TDZ
  - 스코프란 무엇인지?
  - 스코프 관점에서 var let const를 설명해줄 수 있는지?
- 클로저란 무엇인지?
  - (내부 함수는 실행이 종료된 외부 함수의 스코프에 접근할 수 있다고 했는데) 구체적으로 어떻게 접근할 수 있게 되는지?
- CSS selector
- rem은 무엇이고 어떨 때 사용하는지?
- reset CSS, normalize CSS
- (대부분의 프로젝트를 React styled-components로 진행했는데) 일반 CSS 대비 CSS-in-JS의 장단점은 무엇인지?
- (일반적인 홈페이지 시안을 받았다고 할 때) 컴포넌트를 어떻게 분리할 것인지? 그 이유는?
  - state 관리는 전역에서 할 것인지, 해당 컴포넌트 내에서 할 것인지? 그 이유는?
- 경험해본 상태관리 방식(context api, redux ...)에 무엇이 있는지와 장단점, 선택한 이유
- TypeScript나 Flow를 사용해본 경험이 있는지
- (경험이 있는 경우) 도입하게 된 계기와 장단점
- (코테, 시간 부족으로 마지막 답안 미제출한 상황) 마지막 문제를 제출하지 않은 이유는 무엇인지? 시간이 부족했는지? 난이도가 어려워서 포기했는지?
- (과제) 혼자 완성한 것이 맞는지? 부트캠프의 선생님 등이 도와준 것은 아닌지?
- (과제) 시간이 더 있었다면 어떻게 했을 것 같은지? 개선방향, 아쉬운 점 등
- (과제, 답안에서 React.useState가 아니라 React.useReducer를 쓴 상황) 왜 useState를 사용하지 않았는지? 오버엔지니어링에 대해 어떻게 생각하는지?
- (과제, 사용한 라이브러리가 있는 경우) 해당 라이브러리를 선택한 이유와 이점
- 테스트를 작성하는, 테스트가 필요한 이유와 작성시 이점
- 유닛, 통합, e2e 테스트 중 작성해본 테스트가 있는지
  - 유닛 테스트를 작성했을 때의 이점
  - 테스트케이스 정의는 어떻게 하는지
- (시간 등 리소스가 부족한 경우) 일부만 테스트해야한다고 할 때, 테스트 범위와 우선순위 선정은 어떻게 할 것인지?
  - 컴포넌트 테스트는 어떻게 하는지?
- Docker란?
  * Docker는 애플리케이션을 신속하게 구축, 테스트 및 배포할 수 있는 소프트웨어 플랫폼으로, 컨테이너에 라이브러리, 시스템 도구, 코드, 런타임등 소프트웨어를 실행하는 데 필요한 모든 것들이 들어있어서 환경에 구애받지 않고 신속하게 애플리케이션을 배포 및 확장할 수 있습니다.
